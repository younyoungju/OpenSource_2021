전자 계산기 구조
▪교환법칙 : A+B=B+A, A․B=B․A
▪결합법칙 : A+(B+C)=(A+B)+C, A․(B․C)=(A․B)․C
▪분배법칙 : A․(B+C)=A․B+A․C, A+B․C=(A+B)(A+C)
▪멱등법칙 : A+A=A, A․A=A
▪보수법칙 : A+A‘=1, A․A’=0
▪항등법칙 : A+0=A, A+1=1, A․0=0, A․1=A
▪콘센서스 : AB+BC+CA‘=AB+CA’, (A+B)(B+C)(C+A‘)=(A+B)(C+A’)
▪드모르강 : A‘+B’=(A․B)‘, A’․B‘=(A+B)’
▪복원법칙 : A‘’=A


게이트	기호	의미	진리표	 논리식
AND		입력신호가 모두 1일 때 1 출력	A	B	Y
0	0	0
0	1	0
1	0	0
1	1	1	Y=A․B
Y=AB
OR		입력신호 중 1개만 1이어도 1 출력	A	B	Y
0	0	0
0	1	1
1	0	1
1	1	1	Y=A+B
NOT		입력된 정보를 반대로 변환하여 출력	A	Y
0	1
1	0	Y=A'
  -
Y=A
BUFFER		입력된 정보를 그대로 출력	A	Y
0	0
1	1	Y=A
NAND		NOT + AND,
즉 AND의 부정	A	B	Y
0	0	1
0	1	1
1	0	1
1	1	0	   ----
Y=A․B
NOR		NOT + OR,
즉 OR의 부정	A	B	Y
0	0	1
0	1	0
1	0	0
1	1	0	  ----
Y=A+B
XOR		입력되는 값이 모두 같은면 0, 한개라도 틀리면 1출력	A	B	Y
0	0	0
0	1	1
1	0	1
1	1	0	Y=A⊕B
Y=A'B+AB'
Y=(A+B)(A'+B')
Y=(A+B)(AB)'
XNOR		NOT + XOR,
즉 XOR의 부정	A	B	Y
0	0	1
0	1	0
1	0	0
1	1	1	Y=A◉B
  ------
Y=X⊕Y
Y=AB+A'B'
Y=(A'+B)(A+B')
Y=(AB)(A+B)'


1Bit짜리 2진수 2개를 덧셈한 합(S)과 자리올림 수(C)를 구하는 회로
  0
+ 0
0 0
	  0
+ 1
0 1
  1
+ 0
0 1
  1
+ 1
1 0
  A
+ B
C S
  
․S : 합
․C : 자리 올림
진리표
A	B	S	C
0	0	0	0
0	1	1	0
1	0	1	0
1	1	0	1
논리식 : C=A․B   S=A‘․B+A․B’ = A⊕B
논리회로
         


자리 올림수(Ci)를 포함하여 1Bit 크기의 2진수 3자리를 더하여 합(Si)과 자리 올림수(Ci+1)를 구하는 회로
논리식
Ci+1 =A‘BCi+AB’Ci+ABCi‘+ABCi
    =(A‘B+AB’)Ci+AB(Ci‘+Ci)
    =(A⊕B)Ci+AB   ← A‘B+AB’=A⊕B, Ci‘+Ci=1
S   =A'B'Ci+A'BCi'+AB'Ci'+ABCi
	=(A'B'+AB)Ci+(A'B+AB')Ci' 
	=(A⊕B)'Ci+(A⊕B)Ci'  ← A'B'+AB=(A⊕B)', A'B+AB'=A⊕B
	=(A⊕B)⊕Ci 	 ← A⊕B를 X라 하면 X'Ci+XCi' = X⊕Ci = (A⊕B)⊕Ci
회로
전가산기는 2개의 반가산기(HA)와 1개의 OR Gate로 구성된다.



비트(Bit, 
Binary Digit)	․자료(정보) 표현의 최소 단위
․두 가지 상태(0과 1)를 표시하는 2진수 1자리
니블(Nibble)	․4개의 비트(Bit)가 모여 1개의 Nibble을 구성함 
․4비트로 구성되며 16진수 1자리를 표현하기에 적합함 
바이트(Byte)	․문자를 표현하는 최소 단위로, 8개의 비트(Bit)가 모여 1Byte를 구성함 
․1Byte는 256(28)가지의 정보를 표현할 수 있음
․주소 지정의 단위로 사용됨 
워드(Word)	․CPU가 한 번에 처리할 수 있는 명령 단위
․반워드(Half Word) : 2Byte
․풀워드(Full Word) : 4Byte
․더블워드(Double Word) : 8Byte 
필드(Field)	․파일 구성의 최소 단위
․의미 있는 정보를 표현하는 최소 단위  
레코드
(Record)	․하나 이상의 관련된 필드가 모여서 구성됨
․컴퓨터 내부의 자료 처리 단위로서, 일반적으로 레코드는 논리 레코드(Logical Record)를 의미함 
블록(Block)
물리 레코드
(Physical 
Record)	․하나 이상의 논리 레코드가 모여서 구성됨
․각종 저장매체와의 입․출력 단위를 의미하며, 일반적으로 물리 레코드(Physical Record)라고 함 
파일(File)	프로그램 구성의 기본 단위로, 여러 레코드가 모여서 구성됨 
데이터베이스
(Database)	여러 개의 관련된 파일(File)의 집합


컴퓨터가 기본적으로 수행하는 가산을 이용하여 뺄셈을 수행하기 위해 사용함
r의 
보수	․10진법에는 10의 보수가 있고, 2진법에는 2의 보수가 있음
․보수를 구할 숫자의 자리 수만큼 0을 채우고 가장 왼쪽에 1을 추가하여 기준을 만듬
 예) 33의 10의 보수는?
     33+X=100 → X=100-33 → X=67
 예) 10101의 2의 보수는?
     10101+X=100000 → X=100000-10101 → X=01011
r-1의 보수	․10진법에는 9의 보수가 있고, 2진법에는 1의 보수가 있음
․10진수 N에 대한 9의 보수는 주어진 숫자의 자리 수만큼 9를 채워 기준을 만듬
 예) 33의 9의 보수는?
     33+X=99 → X=99-33 → X=66
․2진수 N에 대한 1의 보수는 주어진 숫자의 자리 수만큼 1을 채워 기준을 만듬
 예) 10101의 1의 보수는?
     10101+X=11111 → X=11111-10101 → X=01010


▪정수 값을 2진수로 변환하여 표현하는 방식
▪표현할 수 있는 범위가 작지만 연산 속도가 빠름
종류	표현방법	비고
부호화 절대치법
(Signed Magnitude)	양수표현에 대하여 부호 Bit의 값만 0을 1로 바꾼다.	2가지 형태의 0 존재(+0, -0) 
부호화 1의 보수법
(Signed 1's Complement)	양수 표현에 대하여 1의 보수를 취함
부호화 2의 보수법
(Signed 2's Complement)	양수 표현에 대하여 2의 보수를 취함	한 가지 형태의 0만 존재(+0)
표현범위 
종류	범위	n=8	n=16	n=32
부호화 
절대치법	-2n-1+1 ～ +2n-1-1	-127 ～ +127	-32767 ～ +32767	-231+1 ～+231-1
부호화 1의 보수법
부호화 2의 보수법	-2n-1 ～ +2n-1-1	-128 ～ +127	-32768 ～ +32767	-231 ～ +231-1


BCD(Binary Coded 
Decimal, 2진화 10진 코드)	․6Bit 코드로 IBM에서 개발
․1 개의 문자를 2개의 Zone 비트와 4개의 Digit 비트로 표현함
․6Bit는 26개를 표현할 수 있으므로 64개의 문자를 표현할 수 있음
․1Bit의 Parity Bit를 추가하여 7Bit로 사용함 
․영문 소문자를 표현하지 못함
ASCII 코드(American Standard Co de for Infor mation Inter change)	․7Bit 코드로 미국 표준협회에서 개발
․1개의 문자를 3개의 Zone 비트와 4개의 Digit 비트로 표현함
․27=128가지의 문자를 표현할 수 있음
․1Bit의 Parity Bit를 추가하여 8Bit로 사용함
․통신 제어용 및 마이크로컴퓨터에서 사용함
EBCDIC(Extended BCD In terchange Code, 확장 2진화 10진 코드)	․8Bit 코드로 IBM에서 개발
․1개의 문자를 4개의 Zone 비트와 4개의 Digit 비트로 표현함
․28=256가지의 문자를 표현할 수 있음
․1Bit의 Parity Bit를 추가하여 9Bit로 사용함
․대형 기종의 컴퓨터에서 사용함


BCD 코드	․10진수 1자리의 수를 2진수 4Bit로 표현함
․4Bit의 2진수 각 Bit가 8(23), 4(22), 2(21), 1(20)의 자리값을 가지므로 8421코드라고도 함
․대표적인 가중치 코드
․문자코드인 BCD에서 Zone 부분을 생략한 형태임
․10진수 입.출력이 간편함 
Excess-3 코드
(3초과 코드)	․BCD + 3, 즉 BCD 코드에 310(00112)을 더하여 만든 코드임
․대표적인 자보수 코드이며, 비가중치 코드임
Gray 코드	․BCD 코드의 인접하는 비트를 X-OR 연산하여 만든 코드
․입출력장치, D/A변환기, 주변장치 등에서 숫자를 표현할 때 사용
․1Bit만 변화시켜 다음 수치로 증가시키기 때문에 하드웨어 적인 오류가 적음
패리티 
검사 코드	․코드의 오류를 검사하기 위해서 데이터비트 외에 1Bit의 패리티 체크 비트를 추가하는 것으로 1Bit의 오류만 검출할 수 있음 
․Odd Parity : Odd 패리티는 코드에서 1인 Bit의 수가 홀수가 되도록 0이나 1을 추가함
․Even Parity : Even 패리티는 코드에서 1인 Bit의 수가 짝수가 되도록 0이나 1을 추가함
해밍 코드	․오류를 스스로 검출하여 교정이 가능한 코드
․1Bit의 오류만 교정할 수 있음
․데이터 비트 외에 에러 검출 및 교정을 위한 잉여 비트가 많이 필요함
․해밍코드 중  1, 2, 4, 8, 16 …… 2n 번째 비트는 오류검출을 위한 패리티 비트임


2진수를 Gray Code로 변환하는 방법
① 2진수의 첫 번째 비트는 그대로 내려쓴다.
② 2번째 Gray Bit 부터는 변경할 2진수의 해당 번째 비트와 그 왼쪽의 비트를 X-OR 연산하여 씀
  (예) 2진수 1001을 Gray Code로 변환하시오.
 	2진수 : 1	         0        0         1
      

      Gray Code : 1          1        0         1
Gray Code를 2진수로 변환하는 방법
① 그레이 코드의 첫 번째 비트는 그대로 내려쓴다.
② 2번째 2진수 비트부터는 왼쪽에 구한 그레이 비트와 변경할 해당 번째 2진수 비트를 X-OR 연산하여 씀
   (예) Gray Code 1001을 2진수로 변환하시오.
      Gray Code : 1	        0         0         1

  
          2진수 : 1	        1         1         0


분류	코드 종류
가중치 코드
(Weight Code)	BCD(8421), 2421, 84-2-1, Biquinary(5043210), 51111, Ring-Counter(9876543210)
비가중치 코드
(Non-Weight Code)	3초과(Excess-3), Gray, Jonson, 2-out-of-5, 3-out-of-5
자보수 코드
(Self-Complement Code)	Excess-3, 2421, 51111, 84-2-1
오류 검출용 코드	해밍코드, 패리티 검사 코드, Biquinary, Ring- Counter, 2-out-of-5, 3-out-of-5


제어장치	․컴퓨터에 있는 모든 장치들의 동작을 지시하고 제어하는 장치
․주기억장치에서 읽어 들인 명령어를 해독하여 해당하는 장치에게 제어 신호를 보내 정확하게 수행하도록 지시함
․프로그램 카운터(PC), 명령어레지스터(IR), 부호기(제어신호 발생기), 명령어 해독기, 번지 해독기 등으로 구성되어 있음
연산장치	․제어장치의 명령에 따라 실제로 연산을 수행하는 장치
․연산장치가 수행하는 연산에는 산술연산, 논리연산, 관계연산, 이동(Shift) 등이 있음
․가산기, 누산기(AC ; Accumulator), 보수기, 데이터 레지스터, 오버플로우 검출기, Shift Register 등으로 구성되어 있음
레지스터	․CPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억 장소
․플립플롭(Flip-Flop)이나 래치(Latch)들을 병렬로 연결하여 구성함
․메모리 중에서 가장 속도가 빠름


레지스터	기능
프로그램 카운터, 
프로그램 계수기
(PC, Program Counter)	다음 번에 실행할 명령어의 번지를 기억하는 레지스터
명령 레지스터
(IR, Instruction Register)	현재 실행 중인 명령의 내용을 기억하는 레지스터
누산기
(AC, Accumulator)	연산된 결과를 일시적으로 저장하는 레지스터로 연산의 중심임
상태 레지스터
(Status Register) PSWR
(Program Status Word Register)	․시스템 내부의 순간순간의 상태가 기록된 정보를 PSW라고 함
․오버플로, 언더플로, 자리올림, 인터럽트 등의 PSW를 저장하고 있는 레지스터
메모리 주소 레지스터
(MAR, Memory Address Register)	기억장치를 출입하는 데이터의 번지를 기억하는 레지스터
메모리 버퍼 레지스터
(MBR, Memory Buffer Register)	기억장치를 출입하는 데이터가 잠시 기억되는 레지스터
인덱스 레지스터
(Index Register)	주소의 변경이나 프로그램에서의 반복연산의 횟수를 계수하는 레지스터
데이터 레지스터
(Data Register)	연산에 사용될 데이터를 기억하는 레지스터
Shift Register	․저장된 값을 왼쪽 또는 오른쪽으로 1Bit씩 자리 이동시키는 레지스터
․2배 길이 레지스터라고도 함
Major Status Register	CPU의 메이저 상태를 저장하고 있는 레지스터


CPU, 메모리, I/O장치 등과 상호 필요한 정보를 교환하기 위해 연결하는 공동의 전송선
전송하는 
정보에 
따른 분류	․번지 버스(Address Bus) : CPU가 메모리나 입출력 기기의 번지를 지정할 때 사용하는 단방향 전송선
․자료 버스(Data Bus) : CPU와 메모리 또는 입출력 기기 사이에서 데이터를 전송하는 양방향 버스
․제어 버스(Control Bus) : CPU의 현재 상태나 상태 변경을 메모리 또는 입출력에 알리는 제어신호를 전송하는 선
버스 위치에 
따른 분류	․내부 버스 : CPU 및 메모리 내에 구성된 Bus
․외부 버스 : 주변 입출력장치에 구성된 Bus


Operation Code, 연산자 부	자료부, Operand
연산자 부(Operation Code부)
▪수행해야할 동작에 맞는 연산자를 표시함, 흔히 OP-Code부라고 함
▪연산자부의 크기(비트수)는 표현할 수 있는 명령의  종류를 나타내는 것으로, nBit면 최대 2n개의 명령어를 사용할 수 있음
주소부(Operand부)
▪실제 데이터에 대한 정보를 표시하는 부분임
▪기억장소의 주소, 레지스터 번호, 사용할 데이터 등을 표시함
▪주소부의 크기는 메모리의 용량과 관계가 있음 


함수 
연산 
기능	산술 연산 : ADD, SUB, MUL, DIV, 산술 Shift 등
논리 연산 : NOT, AND, OR, XOR, 논리적 Shift, Rotate, Complement, Clear 등
자료 
전달 
기능	․CPU와 기억장치 사이에서 정보를 교환하는 기능
․Load : 기억장치에 기억되어 있는 정보를 CPU로 꺼내오는 명령
․Store : CPU에 있는 정보를 기억장치에 기억시키는 명령
․Move : 레지스터간에 자료를 전달하는 명령
․Push : 스택에 자료를 저장하는 명령
․Pop : 스택에서 자료를 꺼내오는 명령
제어 
기능	․프로그래머가 명령어 실행 순서를 변경시키는 기능
․무조건 분기 명령 : GOTO, Jump(JMP) 등
․조건 분기 명령  : IF 조건, SPA, SNA, SZA 등
․Call : 부프로그램 호출
․Return : 부프로그램에서 메인 프로그램으로 복귀 
입․출력 기능	․CPU와 I/O장치, 또는 메모리와 I/O장치 사이에서 자료를 전달하는 기능
․INPUT : 입출력 장치의 자료를 주기억장치로 입력하는 명령
․OUTPUT : 주기억 장치의 자료를 입출력 장치로 출력하는 명령


단항연산자 (Unary Operator)	NOT, Complement, Shift, Rotate, MOVE 등
이항연산자 (Binary Operator)	사칙연산, AND, OR, XOR, XNOR


AND
(Masking 
Operation)	․특정 문자 또는 특정 Bit를 삭제(Clear)시키는 명령으로 Masking 명령이라고도 함
․삭제할 부분의 Bit를 0과 AND시켜서 삭제하는데, 대응시키는 0인 Bit를 Mask Bit라고 함
OR
(SelectiveSet)	․특정 문자를 삽입하거나 특정 Bit에 1을 세트시키는 명령으로 Selective Set 연산이라고도 함 
․삽입하거나 세트 시킬 Bit에 삽입할 문자코드 또는 1을 OR 연산시킴
XOR : 비교 (Compare) 명령	․2개의 데이터를 비교하거나, 특정 비트를 반전시킬 때 사용함
․2개의 데이터를 XOR 연산하여 결과에 1Bit라도 1이 있으면 서로 다른 데이터임
․반전시킬 때는 반전시킬 비트와 1을 XOR 시킴
NOT(Complement, 보수)	 각 비트의 값을 반전시키는 연산으로 보수를 구할 때 사용함
논리 Shift	․왼쪽 또는 오른쪽으로 1Bit씩 자리를 이동시키는 연산으로 데이터의 직렬전송(Serial Transfer)에 사용함
․삽입되는 자리는 무조건 0임

Rotate   
  	․Shift에서 밀려 나가는 비트의 값을 반대편 값으로 입력하는 연산임
․문자 위치를 변환할 때 이용
산술 Shift	․부호(Sign)를 고려하여 자리를 이동시키는 연산으로, 2n으로 곱하거나 나눌 때 사용함
․왼쪽으로 n Bit Shift하면 원래 자료에 2n을 곱한 값과 같다.
․오른쪽으로 n Bit Shift 하면 원래 자료를  2n으로 나눈 값과 같음
․홀수를 오른쪽으로 한 번 Shift하면 0.5의 오차가 발생함


3 번지 
명령어	․Operand부가 3개로 구성되는 명령어형식으로 여러 개의 범용레지스터(GPR)를 가진 컴퓨터에서 사용함
․연산의 결과는 Operand3에 기록됨
․연산시 원시 자료를 파괴하지 않음
․다른 형식의 명령어를 이용하는 것보다 프로그램 전체의 길이를 짧게 할 수 있음
․전체 프로그램 실행시 명령 인출을 위하여 주기억장치를 접근하는 횟수가 줄어들어 프로그램 실행속도를 단축시킴
․명령어 한 개의 길이가 너무 길어짐
2 번지 
명령어	․Operand부가 2개로 구성되는 명령어 형식으로 가장 일반적으로 사용되는 명령어 형식
․여러 개의 범용레지스터를 가진 컴퓨터에서 사용함
․3 주소 명령에 비해 명령어의 길이가 짧음
․연산의 결과는 주로 Operand1에 저장되므로 Operand1에 있던 원시자료가 파괴됨
․전체 프로그램의 길이가 길어짐
1 번지 
명령어	․Operand부가 1개로 구성되어 있음
․AC(Accumulator ; 누산기)를 이용하여 명령어를 처리함
0 번지 
명령어	․Operand부 없이 OP Code부만으로 구성됨
․모든 연산은  STACK 메모리의 Stack Pointer가 가리키는 Oper and를 이용하여 수행함
․모든 연산은 스택에 있는 자료를 이용하여 수행하기 때문에 스택머신(Stack Machine)이라고도함
․원래의 자료가 남지 않음


암시적 주소지정 방식
(Implied 
Mode)	주소를 지정하는 필드가 없는 0 번지 명령어에서 Stack의 SP가 가리키는 Operand를 암시하여 이용함
즉치(즉시)적 주소지정방식
(Immediate Mode)	․명령어 자체에 오퍼랜드(실제 데이터)를 내포하고 있는 방식
․별도의 기억장소를 액세스하지 않고 CPU에서 곧바로 자료를 이용할 수 있어서 실행속도가 빠르다는 장점이 있음
․명령어의 길이에 영향을 받으므로 표현할 수 있는 데이터 값의 범위가 제한적임
직접 주소 
지정방식
(Direct 
Mode)	․명령의 주소부(Operand)가 사용할 자료의 번지를 표현하고 있는 방식
․명령의 Operand부에 표현된 주소를 이용하여 실제 데이터가 기억된 기억장소에 직접 사상시킬 수 있음
․기억용량이 2n개의 Word인 메모리 시스템에서 주소를 표현하려면 n 비트의 Operand부가 필요함
간접 주소 
지정방식
(Indirect 
Mode)	․명령어에 나타낼 주소가 명령어 내에서 데이터를 지정하기 위해 할당된 비트(Operand 부의 비트) 수로 나타낼 수 없을 때 사용하는 방식
․명령의 길이가 짧고 제한되어 있어도 긴 주소에 접근 가능함
․명령어 내의 주소부에 실제 데이터가 저장된 장소의 번지를 가진 기억장소의 번지를 표현함으로써, 최소한 주기억장치를 두 번 이상 접근하여 데이터가 있는 기억장소에 도달함
계산에 의한 
주소지정 방식	․상대 주소 지정방식 : 명령어의 주소부분 + PC 
․Base Register Mode : 명령어의 주소부분 + Base Register
․Index Register Mode :  명령어의 주소부분 + Index Reg ister


▪Instruction을 수행하기 위해 CPU내의 레지스터와 플래그가 의미 있는 상태 변환을 하도록 하는 동작
▪레지스터에 저장된 데이터에 의해 이루어지는 동작
▪한 개의 Clock 펼스 동안 실행되는 기본 동작
▪마이크로 오퍼레이션의 순서를 결정하기 위하여 제어장치가 발생하는 신호를 제어신호라고 함
▪한 개의 Instruction은 여러 개의 Micro Operation이 동작되어 실행됨
▪Micro Cycle Time : 한 개의 Micro Operation을 수행하는데 걸리는 시간


동기 
고정식
(Synchronous fixed)	․모든 마이크로 오퍼레이션의 동작시간이 같다고 가정하여 CPU Clock의 주기를 Micro Cycle Time과 같도록 정의하는 방식
․모든 마이크로 오퍼레이션 중에서 수행시간이 가장 긴 마이크로 오퍼레이션의 동작시간을  Micro Cycle Time으로 정함
․모든 마이크로 오퍼레이션의 동작시간이 비슷할 때 유리한 방식임
․장점 : 제어기의 구현이 단순함
․단점 : CPU의 시간 낭비가 심함
동기 
가변식(Synchronous Variable)	․수행시간이 유사한 Micro Operation끼리 그룹을 만들어, 각 그룹별로 서로 다른 Micro Cycle Time을 정의하는 방식
․동기 고정식에 비해 CPU 시간 낭비를 줄일 수 있는 반면, 제어기의 구현은 조금 복잡함
․마이크로 오퍼레이션의 동작시간이 차이가 날 때 유리함(정수배)
비동기식 
(Asynchronous)	․모든 마이크로 오퍼레이션에 대하여 서로 다른 Micro Cycle Time을 정의하는 방식
․CPU의 시간 낭비는 전혀 없으나, 제어기가 매우 복잡해지기 때문에 실제로는 거의 사용되지 않음


▪현재 CPU가 무엇을 하고 있는가를 나타내는 상태로서 fetch, in direct, execute, interrupt 이렇게 4개의 상태가 있음
▪CPU는 메이저 스테이트의 4가지 단계를 반복적으로 거치면서 동작을 수행함
▪메이저 스테이는 메이저 스테이트 레지스터를 통해서 알 수 있음
▪Major Cycle 또는 Machine Cycle라고도 함
▪메이저 스테이트의 변천 과정



▪명령어를 주기억장치에서 중앙처리장치의 명령레지스터로 가져와 해독하는 단계
▪읽어와 해석된 명령어가 1 Cycle 명령이면 이를 수행한 후 다시 Fetch Cycle 사이클로 변천함
▪1 Cycle 명령이 아니면, 해석된 명령어의 모드비트에 따라 직접주소와 간접 주소를 판단함
제어신호	Micro Operation	의미
C0t0	MAR ← PC	PC에 있는 번지를 MAR에 전송시킴
C0t1	MBR ←M[MAR],
PC ← PC + 1	․메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
․다음에 실행할 명령의 위치를 지정하기 위해 PC의 값을 1 증가시킴. 
C0t2	IR ←MBR[OP],


I ← MBR[I]	․명령어의 OP-code 부분을 명령레지스터에 전송함
※현재 MBR에는 주기억 장치에서 읽어온 명령이 들어있음
․명령어의 모드비트를 플립플롭 I에 전송함
C0t3	F ← 1 
또는 R ← 1	I가 0이면 F 플립플롭에 1을 전송하여 Execute 단계로 변천하고, I가 1이면 R 플립플롭에 1을 전송하여 Indirect 단계로 변천함

▪Fetch 단계에서 해석된 명령의 주소부가 간접주소인 경우 수행됨
▪Fetch 단계에서 해석한 주소를 읽어온 후 그 주소가 간접주소이면 유효주소를 계산하기 위해 다시 Indirect 단계를 수행 함
▪간접 주소가 아닌 경우에는 명령어에 따라서 Execute 단계 또는 Fetch 단계로 이동할지를 판단함
제어신호	Micro Operation	의미
C1t0	MAR ← MBR[AD]	MBR에 있는 명령어의 번지 부분을 MAR에 전송함
C1t1	MBR ← M[MAR]	메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
C1t2	No Operation	동작없음
C1t3	F ← 1, R ← 0	F에 1, R에 0을 전송하여 Execute 단계로 변천함


▪Fetch 단계에서 인출하여 해석한 명령을 실행하는 단계
▪플래그 레지스터의 상태 변화를 검사하여 Interrupt 단계로 변천할 것인지를 판단함
▪Interrupt 요청신호를 나타내는 플래그 레지스터의 변화가 없으면 Fetch 단계로 변천함
▪ADD 연산을 수행하는 Execute 단계
제어신호	Micro Operation	의미
C2t0	MAR ← MBR[AD]	MBR에 있는 명령어의 번지 부분을 MAR에 전송함
C2t1	MBR ← M[MAR]	메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
C2t2	AC ← AC + MBR	누산기의 값과 MBR의 값을 더해 누산기에 전송함
※ 실질적인 ADD 연산이 이루어는 부분임
C2t3	F ← 0 
또는 R ←1	F에 0을 전송하면 F=0, R=0이 되어 Fetch 단계로 변천하고, R에 1을 주면 F=1, R=1이 되어 Interrupt 단계로 변천함


▪인터럽트 발생시 복귀주소(PC)를 저장시키고, 제어순서를 인터럽트 처리 프로그램의 첫 번째 명령으로 옮기는 단계
▪인터럽트 단계를 마친 후에는 항상 Fetch 단계로 변천함
제어신호	Micro Operation	의미
C3t0	MBR[AD] ← PC,
PC ← 0	․PC가 가지고 있는, 다음에 실행할 명령의 주소를 MBR의 주소 부분으로 전송함
․복귀 주소를 저장할 0번지를 PC에 전송함
C3t1	MAR ← PC,
PC ← PC + 1	․PC가 가지고 있는, 값 0번지를 MAR에 전송함
․인터럽트 처리 루틴으로 이동할 수 있는 인터럽트 벡터의 위치를 지정하기 위해 PC의 값을 1 증가 시켜 1로 세트시킴
C3t2	M[MAR] ← MBR,
IEN ← 0	․MBR이 가지고 있는, 다음에 실행할 명령의 주소를 메모리의 MAR이 가리키는 위치(0 번지)에 저장함
․인터럽트 단계가 끝날 때까지 다른 인터럽트가 발생하지 않게 IEN에 0을 전송함
C3t3	F ← 0, R ← 0	F에 0, R에 0을 전송하여 Fetch 단계로 변천함
    
ADD : AC ← AC ＋ M[AD]
제어신호	Micro Operation	의미
C2t0	MAR ← MBR[AD]	MBR에 있는 명령어의 번지 부분을 MAR에 전송함
C2t1	MBR ← M[MAR]	메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
C2t2	AC ← AC + MBR	누산기의 값과 MBR의 값을 더해 누산기에 전송함
C2t3	IEN'	F ←0	F에 0을 전송하면 F=0, R=0이 되어 Fetch 단계로 변천함
IEN	R ←1	R에 1을 전송하면 F=1, R=1이 되어 Interrupt 단계로 변천함 
LDA(Load to AC) : AC ← M[AD]
제어신호	Micro Operation	의미
C2t0	MAR ← MBR[AD]	MBR에 있는 명령어의 번지 부분을 MAR에 전송함
C2t1	MBR ← M[MAR]

 AC ← 0	․메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
․AC에 0을 전송하여 AC를 초기화 함
C2t2	AC ← AC + MBR	․메모리에서 가져온 MBR과 AC를 더해 AC에 전송함
․초기화된 AC에 더해지지므로 메모리의 값을 AC로 불러오는것과 같다.
C2t3	IEN'	F ← 0	F에 0을 전송하면 F=0, R=0이 되어 Fetch 단계로 변천함
IEN	R ← 1	R에 1을 전송하면 F=1, R=1이 되어 Interr upt 단계로 변천함 
STA(Store AC) : M[AD]← AC
제어신호	Micro Operation	의미
C2t0	MAR ← MBR[AD]	MBR에 있는 명령어의 번지 부분을 MAR에 전송함
C2t1	MBR ← AC	AC의 값을 MBR에 전송함
C2t2	M[MAR] ←MBR	MBR의 값을 메모리의 MAR이 지정하는 위치에 전송함
C2t3	IEN'	F ← 0	F에 0을 전송하면 F=0, R=0이 되어 Fetch 단계로 변천함
IEN	R ← 1	R에 1을 전송하면 F=1, R=1이 되어 Interrupt 단계로 변천함 
BUN(Branch unconditionally)
BUN은 PC에 특정한 주소를 전송하여 실행명령의 위치를 변경하는 무조건 분기 명령임
제어신호	Micro Operation	의미
C2t0	PC← MBR[AD]	․MBR에 있는 명령어의 번지 부분을 PC에 전송함
※다음에 실행할 명령의 주소를 갖는 PC의 값이 변경되었으므로 변경된 주소에서 다음 명령이 실행됨
C2t1	no Operation	동작없음
C2t2	no Operation	동작없음
C2t3	IEN'	F←0	F에 0을 전송하면 F=0, R=0이 되어 Fetch 단계로 변천함
IEN	R←1	R에 1을 전송하면 F=1, R=1이 되어 Interrupt 단계로 변천함 


제어장치가 제어신호를 발생하기위한 자료로서, CPU가 특정한 메이저 상태와 타이밍 상태에 있을 때 제어자료에 따른 제어규칙에 의해 제어신호가 발생함
① 메이저 스테이트 사이의 변천을 제어하는 데이터
② 중앙처리장치의 제어점을 제어하는 데이터
③ 인스트럭션의 수행 순서를 결정하는데 필요한 제어 테이터


제어장치는 필요한 마이크로 연산들이 연속적으로 수행할 수 있도록 제어 신호를 보내는 역할을 함
	고정배선 제어장치	마이크로 프로그래밍 기법
반응속도	고속	저속
회로 복잡도	복잡	간단
경제성	비경제적	경제적
융통성	없음	있음
구성	하드웨어	소프트웨어

 입․출력 제어 장치	․입․출력 장치와 컴퓨터 사이의 자료전송을 제어하는 장치
․데이터 버퍼 레지스터를 이용하여 두 장치간의 속도차이를 조절함
․제어신호의 논리적, 물리적 변환 그리고 에러를 제어함
․종류 : DMA, 채널, 입․출력 프로세서, 입․출력 컴퓨터
입․출력 인터페이스	․동작방식이나 데이터 형식이 서로 다른 컴퓨터 내부의 주기억 장치나 CPU의 레지스터와 외부 입․출력 장치간의 이진 정보를 원활하게 전송하기 위한 방법을 제공함 
․컴퓨터와 각 주변 장치와의 다음과 같은 차이점을 해결하는 것이 목적임
  - 전자기 혹은 기계적인 주변장치와 전기적인 CPU나 메모리간의 동작방식의 차이
  - 주변 장치와 CPU간의 데이터 전송속도의 차이
  - 주변 장치의 데이터 코드와 CPU나 메모리의 워드 형식의 차이
  - 동작 방식이 서로 다른 주변 장치들의 간섭 없는 제어
입․출력 버스	․주기억장치와 입․출력장치 사이의 데이터 전송을 위해 모든 주변 장치의 인터페이스에 공통으로 연결된 버스
․데이터버스, 주소버스, 제어 버스로 구성되어 있음


기억장치는 처리속도가 nano(10-9)의 단위인 전자적인 장치이고 입출력장치는 milli(10-3)의 단위인 기계적인 장치이므로 동작방식에는 많은 차이가 있음
    비교항목	입․출력 장치	기억 장치
  동작의 속도	느리다	빠르다
  동작의 자율성	타율/자율	타율
  정보의 단위	Byte(문자)	Word
  착오 발생률	많다	적다

▪다중 프로그래밍 환경 하에서 용량이 크고 신속한 액세스가 가능한 디스크를 이용하여 각 사용자 프로그램이 입.출력할 데이터를 직접 I/O 장치로 보내지 않고 디스크에 모았다가 나중에 한꺼번에 입.출력함으로써 입.출력 장치의 공유 및 상대적으로 느린 입.출력 장치의 처리 속도를 보완하는 기법
▪스풀링은 고속의 CPU와 저속의 입.출력장치가 동시에 독립적으로 동작하게 하여 높은 효율로 여러 작업을 병행 작업할 수 있도록 해줌으로써 다중 프로그래밍 시스템의 성능 향상을 가져올 수 있음
▪스풀링은 디스크 일부를 매우 큰 버퍼처럼 사용하는 방법임


Programmed I/O	․원하는 I/O이 완료되었는지의 여부를 검사하기 위해서 CPU가 상태 Flag를 계속 조사하여 I/O가 완료 되었으면 MDR (MBR)과 AC 사이의 자료전송도 CPU가 직접 처리하는 I/O 방식
․입․출력에 필요한 대부분의 일을 CPU가 해주므로 Interface는 MDR, Flag, 장치번호 디코더로만 구성하면 됨
․I/O 작업시 CPU는 계속 I/O 작업에 관여해야 하기 때문에 다른 작업을 할 수 없다는 단점이 있음 
Interrupt I/O	․입․출력을 하기 위해 CPU가 계속 Flag를 검사하지 않고, 데이터를 전송할 준비가 되면 입․출력 인터페이스가 컴퓨터에게 알려 입․출력이 이루어지는 방식임
․입․출력 인터페이스는 CPU에게 인터럽트 신호를 보내 입․출력이 있음을 알림
․CPU는 작업을 수행하던 중 입․출력 인터럽트가 발생하면 수행중인 프로그램을 중단하고 입․출력을 처리한 후 원래의 작업으로 돌아와 작업을 계속 수행함
․CPU가 계속 Flag를 검사하지 않아도 되기 때문에 Programm ed I/O 보다 효율적임
DMA
(Direct Memory Access)에 의한 I/O	․입․출력장치가 직접 주기억장치를 접근(Access)하여 Data Block을 입․출력하는 방식으로 입․출력 전송이 CPU의 레지스터를 경유하지 않고 수행됨
․CPU는 I/O에 필요한 정보를 DMA제어기에 알려서 I/O동작을 개시 시킨 후 I/O동작에 더 이상 간섭하지 않고 다른 프로그램을 할당하여 수행함
․입․출력 자료 전송시 CPU를 거치지 않기 때문에 CPU의 부담없이 보다 빠른 데이터의 전송이 가능함 
․인터럽트 신호를 발생시켜 CPU에게 입․출력 종료를 알림
․Cycle Steal 방식을 이용하여 데이터를 전송함
Channel에 의한 I/O	․CPU를 대신하여 주기억장치와 입․출력장치 사이에서 입․출력을 제어하는 입․출력 전용 프로세서(IOP)임 
․채널 제어기는 채널명령어로 작성된 채널 프로그램을 해독하고 실행하여 입․출력 동작을 처리함
․CPU로부터 입․출력 전송을 위한 명령어를 받으면 CPU와는 독립적으로 동작하여 입․출력을 완료함
․CPU와 인터럽트로 통신함
․채널의 종류
  - Selector Channel : 고속 입․출력장치(자기디스크, 자기테이프,자기드럼)1개와 입․출력하기 위해 사용함
  - Multiplexer Channel : . 저속 입․출력장치(카드리더, 프린터)를 여러개를 동시에 제어하는 채널
  - Block Multiplexer  Channel : 동시에 여러 개의 고속 입․출력장치를 제어함

▪프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황을 우선 처리한 후 실행 중이던 작업으로 복귀하여 계속 처리하는 것, 일명 "끼어들기"라고도 함
▪외부 인터럽트, 내부 인터럽트, 소프트웨어 인터럽트로 분류하는데, 외부나 내부 인터럽트는 CPU의 하드웨어에서의 신호에 의해 발생하고 소프트웨어 인터럽트는 명령어의 수행에 의해 발생함


외부 
인터럽트	․전원 이상 인터럽트 (Power Fail Interrupt) : 정전이 되거나 전원 이상이 있는 경우
․기계 착오 인터럽트 (Machine Check Interrupt) : CPU의 기능적인 오류동작이 발생한 경우
․외부 신호 인터럽트 (External Interrupt)
  - 타이머에 의해 규정된 시간(Time Slice)을 알리는 경우
  - 키보드로 인터럽트 키를 누른 경우
  - 외부장치로부터 인터럽트 요청이 있는 경우
․입․출력 인터럽트 (Input-Output Interrupt)
  - 입․출력 Data의 오류나 이상 현상이 발생한 경우
  - 입․출력장치가 데이터의 전송을 요구하거나 전송이 끝났음을 알릴 경우
내부 
인터럽트	․잘못된 명령이나 데이터를 사용할 때 발생하며, 트랩(Trap)이라고도 부름
․명령어 잘못에 의한 인터럽트 : 프로그램에서 명령어를 잘못 사용한 경우
․프로그램 인터럽트 (Program Interrupt) : 0으로 나누거나, Over flow 또는 Underflow가 발생한 경우
소프트웨어
인터럽트	․프로그램 처리 중 명령의 요청에 의해 발생하는 것으로, 가장 대표적인 형태는 감시 프로그램을 호출하는 SVC(Sup erVisor Call) 인터럽트가 있음
․SVC (Supervisor Call) 인터럽트 : 사용자가 SVC 명령을 써서 의도적으로 호출한 경우


▪프로그램 카운터의 내용
▪사용한 모든 레지스터의 내용
▪상태 조건의 내용(PSW)


① 인터럽트 요청 신호 발생
② 프로그램 실행을 중단함 : 현재 실행 중이던 명령어(Micro Inst ruction)는 끝까지 실행함
③ 현재의 프로그램 상태를 보존함 : 프로그램 상태는 다음에 실행할 명령의 번지로서 PC가 가지고 있음
④ 인터럽트 처리 루틴을 실행함 : 인터럽트를 요청한 장치를 식별함
⑤ 인터럽트 서비스 루틴을 실행함 : 실질적인 인터럽트를 처리함
⑥ 상태복구: 인터럽트 요청신호가 발생했을 때 보관한 PC의 값을 다시 PC에 저장함
⑦ 중단된 프로그램 실행 재개 : PC의 값을 이용하여 인터럽트 발생 이전에 수행 중이던 프로그램을 계속 실행함


▪목적 : 여러 장치에서 동시에 인터럽트가 발생하였을 때 먼저 서비스할 장치를 결정하기 위해서임
▪우선 순위(높음>낮음) : 전원 이상(Power Fail) > 기계착오(Machine Check) > 외부신호(External) > 입출력(I/O) > 명령어 잘못 > 프로그램(Program Check) > SVC(Supervisor Call)


소프트웨어적인 
인터럽트 우선순위 판별방법 : Polling	․Interrupt 발생시 가장 높은 우선순위의 인터럽트 자원(Source)부터 차례로 검사해서, 우선순위가 가장 높은 Interrupt 자원(Source)를 찾아내어 이에 해당하는 인터럽트 서비스 루틴을 수행하는 방식
․소프트웨어적인 방식을 폴링이라고 함
․많은 인터럽트가 있을 때 그들을 모두 조사하는 데 많은 시간이 걸려 반응시간이 느리다는 단점이 있음
․회로가 간단하고 융통성이 있으며 별도의 하드웨어가 필요 없으므로 경제적임
하드웨어적인 인터럽트 우선순위 판별 방법	․CPU와 Interrupt를 요청할 수 있는 장치 사이에 장치 번호에 해당하는 버스를 병렬이나 직렬로 연결하여 요청장치의 번호를 CPU에 알리는 방식
․장치 판별 과정이 간단해서 응답속도가 빠름
․회로가 복잡하고 융통성이 없으며, 추가적인 하드웨어가 필요하므로 비경제적임
․직렬(Serial) 우선순위 부여방식 : 데이지 체인(Daisy-Chain)
  - 인터럽트가 발생하는 모든 장치를 1개의 회선에 직렬로 연결함
  - 우선순위가 높은 장치를 선두에 위치시키고 나머지를 우선순위에 따라 차례로 연결함
  - 직렬 우선순위 부여방식을 데이지 체인 방식이라고 함
․병렬(Parallel) 우선순위 부여방식
  - 인터럽트가 발생하는 각 장치를 개별적인 회선으로 연결함
  - 각 장치의 인터럽트 요청에 따라 각 Bit가 개별적으로 Set될 수 있는 Mask Register를 사용함
  - 우선순위는 Mask Register의 Bit위치에 의해서 결정됨
  - 우선순위가 높은 Interrupt는 낮은 Interrupt가 처리되는 중에도 우선 처리됨


기억용량	기억장치는 무조건 기억용량이 큰 것을 사용한다고 해서 좋은 것이 아니라, 사용목적에 따라 성능당 경비 비율이 적은 것을 사용하는 것이 바람직함 
Access 
Time	․기억장치에 읽기요청이 발생한 시간부터 요구한 정보를 꺼내서 사용 가능할 때까지의 시간
․한 Word단위의 정보를 읽거나 기록하는데 걸리는 시간
․Access time = Seek Time + Latency Time(또는 Serach Time) +  Transmission Time
Cycle 
Time	․기억장치에 읽기신호를 보낸 후 다시 읽기 신호를 보낼 수 있을 때까지의 시간 간격
․Cycle Time ≥ Access Time  
Bandwidth
(대역폭, 
전송률)	․메모리로부터 또는 메모리까지 1초 동안 전송되는 최대한의 정보량으로 기억장치의 자료처리 속도를 나타내는 단위
․메모리 워드의 길이가 작을수록 대역폭이 좋음


구분 방식	구분
내용의 
보존 여부	․파괴성 메모리(Destructive Memory) : 판독 후 저장된 내용이 파괴되는 메모리로, 파괴된 내용을 재생시키기 위한 재저장 시간(Restoration Time)이 필요함 (예)자기 코어
․비파괴성 메모리 : 판독 후에도  저장된 내용이 그대로 유지됨 (예) 자기코어를 제외한 모든 기억장치
전원단절시 내용 소멸 여부	․휘발성 메모리(Volatile Memory) : 전원이 단절되면 모든 정보가 지워지는 메모리 (예) RAM
․비휘발성 메모리 : 전원이 단절되더라도 기억된 정보가 보존되는 메모리 (예) ROM, 자기코어, 보조기억장치
재충전
(Refresh) 여부	․정적메모리(SRAM) : 전원이 공급되는 한 기억된 내용이 계속 유지되는 메모리
․동적메모리(DRAM) : 전원이 공급되어도 일정시간이 지나면 내용이 지워지므로 재충전을 해야 하는 메모리
접근 방식	․직접접근방식(SASD, Sequential Access Storage Device) : 자료가 저장된 위치에 접근할 때, 처음부터 순서대로 접근하여 원하는 위치를 검색하는 메모리 (예) 자기테이프
․직접접근방식(DASD, Direct Access Storage Device) : 순서를 거치지 않고 자료가 저장된 위치를 직접 접근할 수 있는 메모리 (예)자기 테이프를 제외한 모든 기억장치


▪기억된 내용을 읽을 수만 있는 기억장치로서 일반적으로 쓰기는 불가능함
▪전원이 꺼져도 기억된 내용이 지워지지 않는  비휘발성 메모리
▪실제로 ROM은 주기억장치로 사용하기 보다는 주로 기본 입.출력시스템(BIOS), 자가 진단 프로그램(POST) 같은 변경가능성이 희박한 시스템 소프트웨어를 기억시키는데 이용함
▪ROM의 종류와 특징
종 류	특 징
Mask ROM	제조공장에서 프로그램화하여 생산한 ROM으로, 사용자가 내용을 변경시킬 수 없음
PROM
(Programmable 
ROM)	PROM 프로그램장치라는 특수장치를 이용하여 비어 있는 ROM에 사용자가 한번만 내용을 기입할 수 있으며, 이후엔 읽기만 가능함
EPROM
(Erasable PROM)	․자외선을 쏘여서 기입한 내용을 지울 수도 있고, PROM프로그램장치로 기입할 수도 있음
․사용자가 여러 번 반복해서 지우거나 기입할 수 있음
EAROM
(Erasable Alterable ROM)	전기적 특성을 이용하여 기록된 정보의 일부를 바꿀 수 있는 ROM
EEPROM
(Electronic EPROM)	전기적인 방법을 이용하여 기록된 내용을 여러 번 수정하거나 새로운 내용을 기록할 수 있는 ROM


▪자유롭게 읽고 쓸 수 있는 기억장치로, RWM(Read Write Memory)라고도 함
▪RAM에는 현재 사용 중인 프로그램이나 데이터가 저장되어 있음
▪전원이 꺼지면 기억된 내용이 모두 사라지는 휘발성 메모리임
▪일반적으로 ‘주기억장치’ 또는 메모리라고 하면 램을 의미함
▪정보가 저장된 위치는 주소로 구분함
▪SRAM/DRAM의 특징
	동적 램(DRAM)	정적 램(SRAM)
구성 소자	콘덴서	플립플롭
특징	전원이 공급되어도 일정 시간이 지나면 전하가 방전되므로 주기적인 재충전(Refresh)이 필요함	전원이 공급되는 동안에는 기억 내용이 유지됨
전력 소모	적음	많음
접근 속도	느림	빠름
집적도(밀도)	높음	낮음
가격	저가	고가
용도	일반적인 주기억장치	캐시 메모리


▪전류 일치 기술(coincident-current technique)에 의하여 기억장소를 선별함
▪데이터를 읽으면 읽은 내용이 지워지는 파괴메모리(destructive memory) 이므로 내용을 읽은 후 지워진 내용을 기록하기 위한 재저장(restoration time)시간이 필요함
▪자기 코어는 중심을 통과하는 전선에 흐르는 전류의 방향에 따라 1혹은 0의 값을 갖음
▪자기 코어는 부피에 비해 용량이 작고 가격이 비싸 현재는 거의 사용하지 않음
▪자기코어에는 4개의 선이 있음
  - 구동선(X, Y) 2개 : 번지 선택선
  - 센스선 1개 : 자기코어의 상태 검출
  - 금지선 1개 : 불필요하게 자화되었을 때 -1/2 금지 전류를 흘려 자화를 소거시키는 선


자기 
테이프	․순차처리(SASD)만 할 수 있는 대용량 저장매체
․가격이 저렴하고 용량이 커서 자료의 백업용으로 많이 사용함
․자성 물질이 코팅된 얇은 플라스틱 테이프를 동그란 릴에 감아 놓은 형태
․테이프의 시작과 끝부분을 알리는 은박지 사이의 정보 저장부분을 7～9 트랙으로 구성함
자기
디스크
(Magnetic 
Disk)	․자성 물질을 입힌 금속 원판을 여러 장 겹쳐서 만든 기억매체로 용량이 크고 접근 속도가 빠름
․순차, 비순차(직접) 처리가 모두 가능한 DASD(Direct Access Storage Device) 방식으로 데이터를 처리함
․트랙(Track) : 디스크 표면에서 회전축(스핀들 모터)을 중심으로 데이터가 기록되는 동심원
․섹터(Sector) : Track들을 일정한 크기로 구분한 부분이며, 정보 기록의 기본 단위임
․실린더(Cylinder) : 서로 다른 면들에 있는 동일 위치의 Track 들의 모임으로 실린더의 수는 한 면의 트랙 수와 동일함
자기드럼
(Magnetic Drum)	․원통 표면에 Track과 Sector를 구성하고, 각 Track마다 고정된 R/W Head를 두고 있어 자기디스크에 비해 속도가 빠름
․순차, 비순차(직접) 처리가 모두 가능한 DASD(Direct Access Storage Device) 방식으로 데이터를 처리함
․크기에 비해 용량이 적어 현재는 거의 사용하지 않음


▪1개 이상의 논리적 레코드를 묶어서 테이프에 기록하는 방식
IRG	논리
레코드	IRG	논리
레코드	IRG	논리
레코드	IRG	논리
레코드	IRG

↓
IRG	논리
레코드	논리
레코드	논리
레코드	IRG	논리
레코드	논리
레코드	논리
레코드	IRG

▪하나의 블록을 구성하는 논리레코드의 개수를 블록화 인수(BF ; Blocking Factor)라고 함 
▪블로킹을 하면 블로킹을 하지 않았을 때에 비해 IRG의 수가 줄어듦으로 다음과 같은 장점이 있음
․기억공간의 낭비가 줄어듬
․Access Time이 감소함
․입․출력 횟수가 감소함


▪디스크 시스템은 디스크 번호, 디스크 표면 번호, 트랙 번호, 섹터 번호를 표현하는 번지 Bit를 가지고 디스크의 기억공간을 Access함
▪Access Time = Seek Time + Latency Time + Transmission Time
▪Seek Time(탐색 시간) : R/W Head가 특정 트랙까지 이동하는데 걸리는 시간
▪Latency Time(회전 지연 시간) 또는 Search Time : R/W Head가 특정 트랙까지 이동한 후 디스크가 회전하여 트랙에 포함되어 있는 특정 섹터가 R/W Head까지 도달하는데 걸리는 시간
▪Transmission Time(전송 시간) : R/W Head가 Access한 Sector와 주기억장치 간의 자료 전송에 걸리는 시간


연관기억
장치 
(Associative Memor y)	․기억장치에서 자료를 찾을 때 주소에 의해 접근하지 않고, 기억된 내용의 일부를 이용하여 Access할 수 있는 기억장치로 CAM(Content Addressable Memory)이라고도 함
․주소에 의해서만 접근이 가능한 기억장치보다 정보검색이 신속함 
․캐시메모리나 가상메모리관리 기법에서 사용하는 Mapping Table에 사용됨
․외부의 인자와 내용을 비교하기 위한 병렬 판독  논리 회로를 갖고 있기 때문에 하드웨어 비용이 증가함
복수 모듈 기억장치 
(Memory 
Interleaving)	․독자적으로 데이터를 저장할 수 있는 기억장치 모듈을 여러 개 가진 기억장치
․주기억장치와 CPU의 속도차의 문제점을 개선함 
․기억장치 버스를 시분할하여 사용함 
․기억장소의 접근을 보다 빠르게 함 
․복수 모듈 기억장치에 사용되는 각각의 기억장치는 자체의 어드레스 레지스터와 버퍼 레지스터를 가지고 독자적으로 데이터를 저장할 수 있음
․인터리빙 기법에 의해 기억장치를 구성하는 모듈 수만큼의 단어(Word)들에 동시 접근이 가능함
캐시 메모리
(Cache 
Memory)	․CPU의 속도와 메모리의 속도 차이를 줄이기 위해 사용하는 고속 Buffer Memory임
․캐시는 주기억장치와 CPU 사이에 위치함
․캐시 메모리는 메모리 계층 구조에서 가장 빠른 소자이며, 처리속도가 거의 CPU의 속도와 비슷할 정도임
․캐시를 사용하면 기억장치의 접근(access) 시간이 줄어듦으로 컴퓨터의 처리속도가 향상됨
․캐시는 수십 Kbyte～수백 Kbyte의 용량을 사용함 
가상기억장치
(Virtual 
Memory)	․기억용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용할 수 있도록 하는 운영체제의 메모리 운영 기법
․가상기억장치의 목적은 주기억장치의 용량 확보임
․가상 기억장치는 하드웨어적으로 실제로 존재하는 것이 아니고 소프트웨어적인 방법으로 보조기억 장치를 주기억장치처럼 사용하는 것임
․사용자 프로그램을 여러 개의 작은 블록으로 나누어서 보조기억장치 상에 보관해놓고 프로그램 실행시 필요한 부분들만 주기억장치에 적재함
․주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있음 
․가상기억장치 기법에서 사용하는 보조기억장치는 디스크 같은 DASD 장치이어야 함
게이트	기호	의미	진리표	 논리식
AND		입력신호가 모두 1일 때 1 출력	A	B	Y
0	0	0
0	1	0
1	0	0
1	1	1	Y=A․B
Y=AB
OR		입력신호 중 1개만 1이어도 1 출력	A	B	Y
0	0	0
0	1	1
1	0	1
1	1	1	Y=A+B
A	B	Y
0	0	0
0	1	0
1	0	0
1	1	1
A	B	Y
0	0	0
0	1	1
1	0	1
1	1	1
NOT		입력된 정보를 반대로 변환하여 출력	A	Y
0	1
1	0	Y=A'
  -
Y=A
BUFFER		입력된 정보를 그대로 출력	A	Y
0	0
1	1	Y=A
NAND		NOT + AND,
즉 AND의 부정	A	B	Y
0	0	1
0	1	1
1	0	1
1	1	0	   ----
Y=A․B
NOR		NOT + OR,
즉 OR의 부정	A	B	Y
0	0	1
0	1	0
1	0	0
1	1	0	  ----
Y=A+B
XOR		입력되는 값이 모두 같은면 0, 한개라도 틀리면 1출력	A	B	Y
0	0	0
0	1	1
1	0	1
1	1	0	Y=A⊕B
Y=A'B+AB'
Y=(A+B)(A'+B')
Y=(A+B)(AB)'
XNOR		NOT + XOR,
즉 XOR의 부정	A	B	Y
0	0	1
0	1	0
1	0	0
1	1	1	Y=A◉B
  ------
Y=X⊕Y
Y=AB+A'B'
Y=(A'+B)(A+B')
Y=(AB)(A+B)'
A	Y
0	1
1	0
A	Y
0	0
1	1
A	B	Y
0	0	1
0	1	1
1	0	1
1	1	0
A	B	Y
0	0	1
0	1	0
1	0	0
1	1	0
A	B	Y
0	0	0
0	1	1
1	0	1
1	1	0
A	B	Y
0	0	1
0	1	0
1	0	0
1	1	1
  0
+ 0
0 0
  0
+ 1
0 1
  1
+ 0
0 1
  1
+ 1
1 0
  A
+ B
C S
  
․S : 합
․C : 자리 올림
A	B	S	C
0	0	0	0
0	1	1	0
1	0	1	0
1	1	0	1
비트(Bit, 
Binary Digit)	․자료(정보) 표현의 최소 단위
․두 가지 상태(0과 1)를 표시하는 2진수 1자리
니블(Nibble)	․4개의 비트(Bit)가 모여 1개의 Nibble을 구성함 
․4비트로 구성되며 16진수 1자리를 표현하기에 적합함 
바이트(Byte)	․문자를 표현하는 최소 단위로, 8개의 비트(Bit)가 모여 1Byte를 구성함 
․1Byte는 256(28)가지의 정보를 표현할 수 있음
․주소 지정의 단위로 사용됨 
워드(Word)	․CPU가 한 번에 처리할 수 있는 명령 단위
․반워드(Half Word) : 2Byte
․풀워드(Full Word) : 4Byte
․더블워드(Double Word) : 8Byte 
필드(Field)	․파일 구성의 최소 단위
․의미 있는 정보를 표현하는 최소 단위  
레코드
(Record)	․하나 이상의 관련된 필드가 모여서 구성됨
․컴퓨터 내부의 자료 처리 단위로서, 일반적으로 레코드는 논리 레코드(Logical Record)를 의미함 
블록(Block)
물리 레코드
(Physical 
Record)	․하나 이상의 논리 레코드가 모여서 구성됨
․각종 저장매체와의 입․출력 단위를 의미하며, 일반적으로 물리 레코드(Physical Record)라고 함 
파일(File)	프로그램 구성의 기본 단위로, 여러 레코드가 모여서 구성됨 
데이터베이스
(Database)	여러 개의 관련된 파일(File)의 집합
r의 
보수	․10진법에는 10의 보수가 있고, 2진법에는 2의 보수가 있음
․보수를 구할 숫자의 자리 수만큼 0을 채우고 가장 왼쪽에 1을 추가하여 기준을 만듬
 예) 33의 10의 보수는?
     33+X=100 → X=100-33 → X=67
 예) 10101의 2의 보수는?
     10101+X=100000 → X=100000-10101 → X=01011
r-1의 보수	․10진법에는 9의 보수가 있고, 2진법에는 1의 보수가 있음
․10진수 N에 대한 9의 보수는 주어진 숫자의 자리 수만큼 9를 채워 기준을 만듬
 예) 33의 9의 보수는?
     33+X=99 → X=99-33 → X=66
․2진수 N에 대한 1의 보수는 주어진 숫자의 자리 수만큼 1을 채워 기준을 만듬
 예) 10101의 1의 보수는?
     10101+X=11111 → X=11111-10101 → X=01010
종류	표현방법	비고
부호화 절대치법
(Signed Magnitude)	양수표현에 대하여 부호 Bit의 값만 0을 1로 바꾼다.	2가지 형태의 0 존재(+0, -0) 
부호화 1의 보수법
(Signed 1's Complement)	양수 표현에 대하여 1의 보수를 취함
부호화 2의 보수법
(Signed 2's Complement)	양수 표현에 대하여 2의 보수를 취함	한 가지 형태의 0만 존재(+0)
종류	범위	n=8	n=16	n=32
부호화 
절대치법	-2n-1+1 ～ +2n-1-1	-127 ～ +127	-32767 ～ +32767	-231+1 ～+231-1
부호화 1의 보수법
부호화 2의 보수법	-2n-1 ～ +2n-1-1	-128 ～ +127	-32768 ～ +32767	-231 ～ +231-1
BCD(Binary Coded 
Decimal, 2진화 10진 코드)	․6Bit 코드로 IBM에서 개발
․1 개의 문자를 2개의 Zone 비트와 4개의 Digit 비트로 표현함
․6Bit는 26개를 표현할 수 있으므로 64개의 문자를 표현할 수 있음
․1Bit의 Parity Bit를 추가하여 7Bit로 사용함 
․영문 소문자를 표현하지 못함
ASCII 코드(American Standard Co de for Infor mation Inter change)	․7Bit 코드로 미국 표준협회에서 개발
․1개의 문자를 3개의 Zone 비트와 4개의 Digit 비트로 표현함
․27=128가지의 문자를 표현할 수 있음
․1Bit의 Parity Bit를 추가하여 8Bit로 사용함
․통신 제어용 및 마이크로컴퓨터에서 사용함
EBCDIC(Extended BCD In terchange Code, 확장 2진화 10진 코드)	․8Bit 코드로 IBM에서 개발
․1개의 문자를 4개의 Zone 비트와 4개의 Digit 비트로 표현함
․28=256가지의 문자를 표현할 수 있음
․1Bit의 Parity Bit를 추가하여 9Bit로 사용함
․대형 기종의 컴퓨터에서 사용함
BCD 코드	․10진수 1자리의 수를 2진수 4Bit로 표현함
․4Bit의 2진수 각 Bit가 8(23), 4(22), 2(21), 1(20)의 자리값을 가지므로 8421코드라고도 함
․대표적인 가중치 코드
․문자코드인 BCD에서 Zone 부분을 생략한 형태임
․10진수 입.출력이 간편함 
Excess-3 코드
(3초과 코드)	․BCD + 3, 즉 BCD 코드에 310(00112)을 더하여 만든 코드임
․대표적인 자보수 코드이며, 비가중치 코드임
Gray 코드	․BCD 코드의 인접하는 비트를 X-OR 연산하여 만든 코드
․입출력장치, D/A변환기, 주변장치 등에서 숫자를 표현할 때 사용
․1Bit만 변화시켜 다음 수치로 증가시키기 때문에 하드웨어 적인 오류가 적음
패리티 
검사 코드	․코드의 오류를 검사하기 위해서 데이터비트 외에 1Bit의 패리티 체크 비트를 추가하는 것으로 1Bit의 오류만 검출할 수 있음 
․Odd Parity : Odd 패리티는 코드에서 1인 Bit의 수가 홀수가 되도록 0이나 1을 추가함
․Even Parity : Even 패리티는 코드에서 1인 Bit의 수가 짝수가 되도록 0이나 1을 추가함
해밍 코드	․오류를 스스로 검출하여 교정이 가능한 코드
․1Bit의 오류만 교정할 수 있음
․데이터 비트 외에 에러 검출 및 교정을 위한 잉여 비트가 많이 필요함
․해밍코드 중  1, 2, 4, 8, 16 …… 2n 번째 비트는 오류검출을 위한 패리티 비트임
분류	코드 종류
가중치 코드
(Weight Code)	BCD(8421), 2421, 84-2-1, Biquinary(5043210), 51111, Ring-Counter(9876543210)
비가중치 코드
(Non-Weight Code)	3초과(Excess-3), Gray, Jonson, 2-out-of-5, 3-out-of-5
자보수 코드
(Self-Complement Code)	Excess-3, 2421, 51111, 84-2-1
오류 검출용 코드	해밍코드, 패리티 검사 코드, Biquinary, Ring- Counter, 2-out-of-5, 3-out-of-5
제어장치	․컴퓨터에 있는 모든 장치들의 동작을 지시하고 제어하는 장치
․주기억장치에서 읽어 들인 명령어를 해독하여 해당하는 장치에게 제어 신호를 보내 정확하게 수행하도록 지시함
․프로그램 카운터(PC), 명령어레지스터(IR), 부호기(제어신호 발생기), 명령어 해독기, 번지 해독기 등으로 구성되어 있음
연산장치	․제어장치의 명령에 따라 실제로 연산을 수행하는 장치
․연산장치가 수행하는 연산에는 산술연산, 논리연산, 관계연산, 이동(Shift) 등이 있음
․가산기, 누산기(AC ; Accumulator), 보수기, 데이터 레지스터, 오버플로우 검출기, Shift Register 등으로 구성되어 있음
레지스터	․CPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억 장소
․플립플롭(Flip-Flop)이나 래치(Latch)들을 병렬로 연결하여 구성함
․메모리 중에서 가장 속도가 빠름
레지스터	기능
프로그램 카운터, 
프로그램 계수기
(PC, Program Counter)	다음 번에 실행할 명령어의 번지를 기억하는 레지스터
명령 레지스터
(IR, Instruction Register)	현재 실행 중인 명령의 내용을 기억하는 레지스터
누산기
(AC, Accumulator)	연산된 결과를 일시적으로 저장하는 레지스터로 연산의 중심임
상태 레지스터
(Status Register) PSWR
(Program Status Word Register)	․시스템 내부의 순간순간의 상태가 기록된 정보를 PSW라고 함
․오버플로, 언더플로, 자리올림, 인터럽트 등의 PSW를 저장하고 있는 레지스터
메모리 주소 레지스터
(MAR, Memory Address Register)	기억장치를 출입하는 데이터의 번지를 기억하는 레지스터
메모리 버퍼 레지스터
(MBR, Memory Buffer Register)	기억장치를 출입하는 데이터가 잠시 기억되는 레지스터
인덱스 레지스터
(Index Register)	주소의 변경이나 프로그램에서의 반복연산의 횟수를 계수하는 레지스터
데이터 레지스터
(Data Register)	연산에 사용될 데이터를 기억하는 레지스터
Shift Register	․저장된 값을 왼쪽 또는 오른쪽으로 1Bit씩 자리 이동시키는 레지스터
․2배 길이 레지스터라고도 함
Major Status Register	CPU의 메이저 상태를 저장하고 있는 레지스터
전송하는 
정보에 
따른 분류	․번지 버스(Address Bus) : CPU가 메모리나 입출력 기기의 번지를 지정할 때 사용하는 단방향 전송선
․자료 버스(Data Bus) : CPU와 메모리 또는 입출력 기기 사이에서 데이터를 전송하는 양방향 버스
․제어 버스(Control Bus) : CPU의 현재 상태나 상태 변경을 메모리 또는 입출력에 알리는 제어신호를 전송하는 선
버스 위치에 
따른 분류	․내부 버스 : CPU 및 메모리 내에 구성된 Bus
․외부 버스 : 주변 입출력장치에 구성된 Bus
Operation Code, 연산자 부	자료부, Operand
함수 
연산 
기능	산술 연산 : ADD, SUB, MUL, DIV, 산술 Shift 등
논리 연산 : NOT, AND, OR, XOR, 논리적 Shift, Rotate, Complement, Clear 등
자료 
전달 
기능	․CPU와 기억장치 사이에서 정보를 교환하는 기능
․Load : 기억장치에 기억되어 있는 정보를 CPU로 꺼내오는 명령
․Store : CPU에 있는 정보를 기억장치에 기억시키는 명령
․Move : 레지스터간에 자료를 전달하는 명령
․Push : 스택에 자료를 저장하는 명령
․Pop : 스택에서 자료를 꺼내오는 명령
제어 
기능	․프로그래머가 명령어 실행 순서를 변경시키는 기능
․무조건 분기 명령 : GOTO, Jump(JMP) 등
․조건 분기 명령  : IF 조건, SPA, SNA, SZA 등
․Call : 부프로그램 호출
․Return : 부프로그램에서 메인 프로그램으로 복귀 
입․출력 기능	․CPU와 I/O장치, 또는 메모리와 I/O장치 사이에서 자료를 전달하는 기능
․INPUT : 입출력 장치의 자료를 주기억장치로 입력하는 명령
․OUTPUT : 주기억 장치의 자료를 입출력 장치로 출력하는 명령
단항연산자 (Unary Operator)	NOT, Complement, Shift, Rotate, MOVE 등
이항연산자 (Binary Operator)	사칙연산, AND, OR, XOR, XNOR
AND
(Masking 
Operation)	․특정 문자 또는 특정 Bit를 삭제(Clear)시키는 명령으로 Masking 명령이라고도 함
․삭제할 부분의 Bit를 0과 AND시켜서 삭제하는데, 대응시키는 0인 Bit를 Mask Bit라고 함
OR
(SelectiveSet)	․특정 문자를 삽입하거나 특정 Bit에 1을 세트시키는 명령으로 Selective Set 연산이라고도 함 
․삽입하거나 세트 시킬 Bit에 삽입할 문자코드 또는 1을 OR 연산시킴
XOR : 비교 (Compare) 명령	․2개의 데이터를 비교하거나, 특정 비트를 반전시킬 때 사용함
․2개의 데이터를 XOR 연산하여 결과에 1Bit라도 1이 있으면 서로 다른 데이터임
․반전시킬 때는 반전시킬 비트와 1을 XOR 시킴
NOT(Complement, 보수)	 각 비트의 값을 반전시키는 연산으로 보수를 구할 때 사용함
논리 Shift	․왼쪽 또는 오른쪽으로 1Bit씩 자리를 이동시키는 연산으로 데이터의 직렬전송(Serial Transfer)에 사용함
․삽입되는 자리는 무조건 0임

Rotate   
  	․Shift에서 밀려 나가는 비트의 값을 반대편 값으로 입력하는 연산임
․문자 위치를 변환할 때 이용
산술 Shift	․부호(Sign)를 고려하여 자리를 이동시키는 연산으로, 2n으로 곱하거나 나눌 때 사용함
․왼쪽으로 n Bit Shift하면 원래 자료에 2n을 곱한 값과 같다.
․오른쪽으로 n Bit Shift 하면 원래 자료를  2n으로 나눈 값과 같음
․홀수를 오른쪽으로 한 번 Shift하면 0.5의 오차가 발생함
3 번지 
명령어	․Operand부가 3개로 구성되는 명령어형식으로 여러 개의 범용레지스터(GPR)를 가진 컴퓨터에서 사용함
․연산의 결과는 Operand3에 기록됨
․연산시 원시 자료를 파괴하지 않음
․다른 형식의 명령어를 이용하는 것보다 프로그램 전체의 길이를 짧게 할 수 있음
․전체 프로그램 실행시 명령 인출을 위하여 주기억장치를 접근하는 횟수가 줄어들어 프로그램 실행속도를 단축시킴
․명령어 한 개의 길이가 너무 길어짐
2 번지 
명령어	․Operand부가 2개로 구성되는 명령어 형식으로 가장 일반적으로 사용되는 명령어 형식
․여러 개의 범용레지스터를 가진 컴퓨터에서 사용함
․3 주소 명령에 비해 명령어의 길이가 짧음
․연산의 결과는 주로 Operand1에 저장되므로 Operand1에 있던 원시자료가 파괴됨
․전체 프로그램의 길이가 길어짐
1 번지 
명령어	․Operand부가 1개로 구성되어 있음
․AC(Accumulator ; 누산기)를 이용하여 명령어를 처리함
0 번지 
명령어	․Operand부 없이 OP Code부만으로 구성됨
․모든 연산은  STACK 메모리의 Stack Pointer가 가리키는 Oper and를 이용하여 수행함
․모든 연산은 스택에 있는 자료를 이용하여 수행하기 때문에 스택머신(Stack Machine)이라고도함
․원래의 자료가 남지 않음
암시적 주소지정 방식
(Implied 
Mode)	주소를 지정하는 필드가 없는 0 번지 명령어에서 Stack의 SP가 가리키는 Operand를 암시하여 이용함
즉치(즉시)적 주소지정방식
(Immediate Mode)	․명령어 자체에 오퍼랜드(실제 데이터)를 내포하고 있는 방식
․별도의 기억장소를 액세스하지 않고 CPU에서 곧바로 자료를 이용할 수 있어서 실행속도가 빠르다는 장점이 있음
․명령어의 길이에 영향을 받으므로 표현할 수 있는 데이터 값의 범위가 제한적임
직접 주소 
지정방식
(Direct 
Mode)	․명령의 주소부(Operand)가 사용할 자료의 번지를 표현하고 있는 방식
․명령의 Operand부에 표현된 주소를 이용하여 실제 데이터가 기억된 기억장소에 직접 사상시킬 수 있음
․기억용량이 2n개의 Word인 메모리 시스템에서 주소를 표현하려면 n 비트의 Operand부가 필요함
간접 주소 
지정방식
(Indirect 
Mode)	․명령어에 나타낼 주소가 명령어 내에서 데이터를 지정하기 위해 할당된 비트(Operand 부의 비트) 수로 나타낼 수 없을 때 사용하는 방식
․명령의 길이가 짧고 제한되어 있어도 긴 주소에 접근 가능함
․명령어 내의 주소부에 실제 데이터가 저장된 장소의 번지를 가진 기억장소의 번지를 표현함으로써, 최소한 주기억장치를 두 번 이상 접근하여 데이터가 있는 기억장소에 도달함
계산에 의한 
주소지정 방식	․상대 주소 지정방식 : 명령어의 주소부분 + PC 
․Base Register Mode : 명령어의 주소부분 + Base Register
․Index Register Mode :  명령어의 주소부분 + Index Reg ister
동기 
고정식
(Synchronous fixed)	․모든 마이크로 오퍼레이션의 동작시간이 같다고 가정하여 CPU Clock의 주기를 Micro Cycle Time과 같도록 정의하는 방식
․모든 마이크로 오퍼레이션 중에서 수행시간이 가장 긴 마이크로 오퍼레이션의 동작시간을  Micro Cycle Time으로 정함
․모든 마이크로 오퍼레이션의 동작시간이 비슷할 때 유리한 방식임
․장점 : 제어기의 구현이 단순함
․단점 : CPU의 시간 낭비가 심함
동기 
가변식(Synchronous Variable)	․수행시간이 유사한 Micro Operation끼리 그룹을 만들어, 각 그룹별로 서로 다른 Micro Cycle Time을 정의하는 방식
․동기 고정식에 비해 CPU 시간 낭비를 줄일 수 있는 반면, 제어기의 구현은 조금 복잡함
․마이크로 오퍼레이션의 동작시간이 차이가 날 때 유리함(정수배)
비동기식 
(Asynchronous)	․모든 마이크로 오퍼레이션에 대하여 서로 다른 Micro Cycle Time을 정의하는 방식
․CPU의 시간 낭비는 전혀 없으나, 제어기가 매우 복잡해지기 때문에 실제로는 거의 사용되지 않음
제어신호	Micro Operation	의미
C0t0	MAR ← PC	PC에 있는 번지를 MAR에 전송시킴
C0t1	MBR ←M[MAR],
PC ← PC + 1	․메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
․다음에 실행할 명령의 위치를 지정하기 위해 PC의 값을 1 증가시킴. 
C0t2	IR ←MBR[OP],


I ← MBR[I]	․명령어의 OP-code 부분을 명령레지스터에 전송함
※현재 MBR에는 주기억 장치에서 읽어온 명령이 들어있음
․명령어의 모드비트를 플립플롭 I에 전송함
C0t3	F ← 1 
또는 R ← 1	I가 0이면 F 플립플롭에 1을 전송하여 Execute 단계로 변천하고, I가 1이면 R 플립플롭에 1을 전송하여 Indirect 단계로 변천함
제어신호	Micro Operation	의미
C1t0	MAR ← MBR[AD]	MBR에 있는 명령어의 번지 부분을 MAR에 전송함
C1t1	MBR ← M[MAR]	메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
C1t2	No Operation	동작없음
C1t3	F ← 1, R ← 0	F에 1, R에 0을 전송하여 Execute 단계로 변천함
제어신호	Micro Operation	의미
C2t0	MAR ← MBR[AD]	MBR에 있는 명령어의 번지 부분을 MAR에 전송함
C2t1	MBR ← M[MAR]	메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
C2t2	AC ← AC + MBR	누산기의 값과 MBR의 값을 더해 누산기에 전송함
※ 실질적인 ADD 연산이 이루어는 부분임
C2t3	F ← 0 
또는 R ←1	F에 0을 전송하면 F=0, R=0이 되어 Fetch 단계로 변천하고, R에 1을 주면 F=1, R=1이 되어 Interrupt 단계로 변천함
제어신호	Micro Operation	의미
C3t0	MBR[AD] ← PC,
PC ← 0	․PC가 가지고 있는, 다음에 실행할 명령의 주소를 MBR의 주소 부분으로 전송함
․복귀 주소를 저장할 0번지를 PC에 전송함
C3t1	MAR ← PC,
PC ← PC + 1	․PC가 가지고 있는, 값 0번지를 MAR에 전송함
․인터럽트 처리 루틴으로 이동할 수 있는 인터럽트 벡터의 위치를 지정하기 위해 PC의 값을 1 증가 시켜 1로 세트시킴
C3t2	M[MAR] ← MBR,
IEN ← 0	․MBR이 가지고 있는, 다음에 실행할 명령의 주소를 메모리의 MAR이 가리키는 위치(0 번지)에 저장함
․인터럽트 단계가 끝날 때까지 다른 인터럽트가 발생하지 않게 IEN에 0을 전송함
C3t3	F ← 0, R ← 0	F에 0, R에 0을 전송하여 Fetch 단계로 변천함
제어신호	Micro Operation	의미
C2t0	MAR ← MBR[AD]	MBR에 있는 명령어의 번지 부분을 MAR에 전송함
C2t1	MBR ← M[MAR]	메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
C2t2	AC ← AC + MBR	누산기의 값과 MBR의 값을 더해 누산기에 전송함
C2t3	IEN'	F ←0	F에 0을 전송하면 F=0, R=0이 되어 Fetch 단계로 변천함
IEN	R ←1	R에 1을 전송하면 F=1, R=1이 되어 Interrupt 단계로 변천함 
제어신호	Micro Operation	의미
C2t0	MAR ← MBR[AD]	MBR에 있는 명령어의 번지 부분을 MAR에 전송함
C2t1	MBR ← M[MAR]

 AC ← 0	․메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
․AC에 0을 전송하여 AC를 초기화 함
C2t2	AC ← AC + MBR	․메모리에서 가져온 MBR과 AC를 더해 AC에 전송함
․초기화된 AC에 더해지지므로 메모리의 값을 AC로 불러오는것과 같다.
C2t3	IEN'	F ← 0	F에 0을 전송하면 F=0, R=0이 되어 Fetch 단계로 변천함
IEN	R ← 1	R에 1을 전송하면 F=1, R=1이 되어 Interr upt 단계로 변천함 
제어신호	Micro Operation	의미
C2t0	MAR ← MBR[AD]	MBR에 있는 명령어의 번지 부분을 MAR에 전송함
C2t1	MBR ← AC	AC의 값을 MBR에 전송함
C2t2	M[MAR] ←MBR	MBR의 값을 메모리의 MAR이 지정하는 위치에 전송함
C2t3	IEN'	F ← 0	F에 0을 전송하면 F=0, R=0이 되어 Fetch 단계로 변천함
IEN	R ← 1	R에 1을 전송하면 F=1, R=1이 되어 Interrupt 단계로 변천함 
제어신호	Micro Operation	의미
C2t0	PC← MBR[AD]	․MBR에 있는 명령어의 번지 부분을 PC에 전송함
※다음에 실행할 명령의 주소를 갖는 PC의 값이 변경되었으므로 변경된 주소에서 다음 명령이 실행됨
C2t1	no Operation	동작없음
C2t2	no Operation	동작없음
C2t3	IEN'	F←0	F에 0을 전송하면 F=0, R=0이 되어 Fetch 단계로 변천함
IEN	R←1	R에 1을 전송하면 F=1, R=1이 되어 Interrupt 단계로 변천함 
	고정배선 제어장치	마이크로 프로그래밍 기법
반응속도	고속	저속
회로 복잡도	복잡	간단
경제성	비경제적	경제적
융통성	없음	있음
구성	하드웨어	소프트웨어
입․출력 제어 장치	․입․출력 장치와 컴퓨터 사이의 자료전송을 제어하는 장치
․데이터 버퍼 레지스터를 이용하여 두 장치간의 속도차이를 조절함
․제어신호의 논리적, 물리적 변환 그리고 에러를 제어함
․종류 : DMA, 채널, 입․출력 프로세서, 입․출력 컴퓨터
입․출력 인터페이스	․동작방식이나 데이터 형식이 서로 다른 컴퓨터 내부의 주기억 장치나 CPU의 레지스터와 외부 입․출력 장치간의 이진 정보를 원활하게 전송하기 위한 방법을 제공함 
․컴퓨터와 각 주변 장치와의 다음과 같은 차이점을 해결하는 것이 목적임
  - 전자기 혹은 기계적인 주변장치와 전기적인 CPU나 메모리간의 동작방식의 차이
  - 주변 장치와 CPU간의 데이터 전송속도의 차이
  - 주변 장치의 데이터 코드와 CPU나 메모리의 워드 형식의 차이
  - 동작 방식이 서로 다른 주변 장치들의 간섭 없는 제어
입․출력 버스	․주기억장치와 입․출력장치 사이의 데이터 전송을 위해 모든 주변 장치의 인터페이스에 공통으로 연결된 버스
․데이터버스, 주소버스, 제어 버스로 구성되어 있음
 비교항목	입․출력 장치	기억 장치
  동작의 속도	느리다	빠르다
  동작의 자율성	타율/자율	타율
  정보의 단위	Byte(문자)	Word
  착오 발생률	많다	적다
Programmed I/O	․원하는 I/O이 완료되었는지의 여부를 검사하기 위해서 CPU가 상태 Flag를 계속 조사하여 I/O가 완료 되었으면 MDR (MBR)과 AC 사이의 자료전송도 CPU가 직접 처리하는 I/O 방식
․입․출력에 필요한 대부분의 일을 CPU가 해주므로 Interface는 MDR, Flag, 장치번호 디코더로만 구성하면 됨
․I/O 작업시 CPU는 계속 I/O 작업에 관여해야 하기 때문에 다른 작업을 할 수 없다는 단점이 있음 
Interrupt I/O	․입․출력을 하기 위해 CPU가 계속 Flag를 검사하지 않고, 데이터를 전송할 준비가 되면 입․출력 인터페이스가 컴퓨터에게 알려 입․출력이 이루어지는 방식임
․입․출력 인터페이스는 CPU에게 인터럽트 신호를 보내 입․출력이 있음을 알림
․CPU는 작업을 수행하던 중 입․출력 인터럽트가 발생하면 수행중인 프로그램을 중단하고 입․출력을 처리한 후 원래의 작업으로 돌아와 작업을 계속 수행함
․CPU가 계속 Flag를 검사하지 않아도 되기 때문에 Programm ed I/O 보다 효율적임
DMA
(Direct Memory Access)에 의한 I/O	․입․출력장치가 직접 주기억장치를 접근(Access)하여 Data Block을 입․출력하는 방식으로 입․출력 전송이 CPU의 레지스터를 경유하지 않고 수행됨
․CPU는 I/O에 필요한 정보를 DMA제어기에 알려서 I/O동작을 개시 시킨 후 I/O동작에 더 이상 간섭하지 않고 다른 프로그램을 할당하여 수행함
․입․출력 자료 전송시 CPU를 거치지 않기 때문에 CPU의 부담없이 보다 빠른 데이터의 전송이 가능함 
․인터럽트 신호를 발생시켜 CPU에게 입․출력 종료를 알림
․Cycle Steal 방식을 이용하여 데이터를 전송함
Channel에 의한 I/O	․CPU를 대신하여 주기억장치와 입․출력장치 사이에서 입․출력을 제어하는 입․출력 전용 프로세서(IOP)임 
․채널 제어기는 채널명령어로 작성된 채널 프로그램을 해독하고 실행하여 입․출력 동작을 처리함
․CPU로부터 입․출력 전송을 위한 명령어를 받으면 CPU와는 독립적으로 동작하여 입․출력을 완료함
․CPU와 인터럽트로 통신함
․채널의 종류
  - Selector Channel : 고속 입․출력장치(자기디스크, 자기테이프,자기드럼)1개와 입․출력하기 위해 사용함
  - Multiplexer Channel : . 저속 입․출력장치(카드리더, 프린터)를 여러개를 동시에 제어하는 채널
  - Block Multiplexer  Channel : 동시에 여러 개의 고속 입․출력장치를 제어함
외부 
인터럽트	․전원 이상 인터럽트 (Power Fail Interrupt) : 정전이 되거나 전원 이상이 있는 경우
․기계 착오 인터럽트 (Machine Check Interrupt) : CPU의 기능적인 오류동작이 발생한 경우
․외부 신호 인터럽트 (External Interrupt)
  - 타이머에 의해 규정된 시간(Time Slice)을 알리는 경우
  - 키보드로 인터럽트 키를 누른 경우
  - 외부장치로부터 인터럽트 요청이 있는 경우
․입․출력 인터럽트 (Input-Output Interrupt)
  - 입․출력 Data의 오류나 이상 현상이 발생한 경우
  - 입․출력장치가 데이터의 전송을 요구하거나 전송이 끝났음을 알릴 경우
내부 
인터럽트	․잘못된 명령이나 데이터를 사용할 때 발생하며, 트랩(Trap)이라고도 부름
․명령어 잘못에 의한 인터럽트 : 프로그램에서 명령어를 잘못 사용한 경우
․프로그램 인터럽트 (Program Interrupt) : 0으로 나누거나, Over flow 또는 Underflow가 발생한 경우
소프트웨어
인터럽트	․프로그램 처리 중 명령의 요청에 의해 발생하는 것으로, 가장 대표적인 형태는 감시 프로그램을 호출하는 SVC(Sup erVisor Call) 인터럽트가 있음
․SVC (Supervisor Call) 인터럽트 : 사용자가 SVC 명령을 써서 의도적으로 호출한 경우
소프트웨어적인 
인터럽트 우선순위 판별방법 : Polling	․Interrupt 발생시 가장 높은 우선순위의 인터럽트 자원(Source)부터 차례로 검사해서, 우선순위가 가장 높은 Interrupt 자원(Source)를 찾아내어 이에 해당하는 인터럽트 서비스 루틴을 수행하는 방식
․소프트웨어적인 방식을 폴링이라고 함
․많은 인터럽트가 있을 때 그들을 모두 조사하는 데 많은 시간이 걸려 반응시간이 느리다는 단점이 있음
․회로가 간단하고 융통성이 있으며 별도의 하드웨어가 필요 없으므로 경제적임
하드웨어적인 인터럽트 우선순위 판별 방법	․CPU와 Interrupt를 요청할 수 있는 장치 사이에 장치 번호에 해당하는 버스를 병렬이나 직렬로 연결하여 요청장치의 번호를 CPU에 알리는 방식
․장치 판별 과정이 간단해서 응답속도가 빠름
․회로가 복잡하고 융통성이 없으며, 추가적인 하드웨어가 필요하므로 비경제적임
․직렬(Serial) 우선순위 부여방식 : 데이지 체인(Daisy-Chain)
  - 인터럽트가 발생하는 모든 장치를 1개의 회선에 직렬로 연결함
  - 우선순위가 높은 장치를 선두에 위치시키고 나머지를 우선순위에 따라 차례로 연결함
  - 직렬 우선순위 부여방식을 데이지 체인 방식이라고 함
․병렬(Parallel) 우선순위 부여방식
  - 인터럽트가 발생하는 각 장치를 개별적인 회선으로 연결함
  - 각 장치의 인터럽트 요청에 따라 각 Bit가 개별적으로 Set될 수 있는 Mask Register를 사용함
  - 우선순위는 Mask Register의 Bit위치에 의해서 결정됨
  - 우선순위가 높은 Interrupt는 낮은 Interrupt가 처리되는 중에도 우선 처리됨
기억용량	기억장치는 무조건 기억용량이 큰 것을 사용한다고 해서 좋은 것이 아니라, 사용목적에 따라 성능당 경비 비율이 적은 것을 사용하는 것이 바람직함 
Access 
Time	․기억장치에 읽기요청이 발생한 시간부터 요구한 정보를 꺼내서 사용 가능할 때까지의 시간
․한 Word단위의 정보를 읽거나 기록하는데 걸리는 시간
․Access time = Seek Time + Latency Time(또는 Serach Time) +  Transmission Time
Cycle 
Time	․기억장치에 읽기신호를 보낸 후 다시 읽기 신호를 보낼 수 있을 때까지의 시간 간격
․Cycle Time ≥ Access Time  
Bandwidth
(대역폭, 
전송률)	․메모리로부터 또는 메모리까지 1초 동안 전송되는 최대한의 정보량으로 기억장치의 자료처리 속도를 나타내는 단위
․메모리 워드의 길이가 작을수록 대역폭이 좋음
구분 방식	구분
내용의 
보존 여부	․파괴성 메모리(Destructive Memory) : 판독 후 저장된 내용이 파괴되는 메모리로, 파괴된 내용을 재생시키기 위한 재저장 시간(Restoration Time)이 필요함 (예)자기 코어
․비파괴성 메모리 : 판독 후에도  저장된 내용이 그대로 유지됨 (예) 자기코어를 제외한 모든 기억장치
전원단절시 내용 소멸 여부	․휘발성 메모리(Volatile Memory) : 전원이 단절되면 모든 정보가 지워지는 메모리 (예) RAM
․비휘발성 메모리 : 전원이 단절되더라도 기억된 정보가 보존되는 메모리 (예) ROM, 자기코어, 보조기억장치
재충전
(Refresh) 여부	․정적메모리(SRAM) : 전원이 공급되는 한 기억된 내용이 계속 유지되는 메모리
․동적메모리(DRAM) : 전원이 공급되어도 일정시간이 지나면 내용이 지워지므로 재충전을 해야 하는 메모리
접근 방식	․직접접근방식(SASD, Sequential Access Storage Device) : 자료가 저장된 위치에 접근할 때, 처음부터 순서대로 접근하여 원하는 위치를 검색하는 메모리 (예) 자기테이프
․직접접근방식(DASD, Direct Access Storage Device) : 순서를 거치지 않고 자료가 저장된 위치를 직접 접근할 수 있는 메모리 (예)자기 테이프를 제외한 모든 기억장치
종 류	특 징
Mask ROM	제조공장에서 프로그램화하여 생산한 ROM으로, 사용자가 내용을 변경시킬 수 없음
PROM
(Programmable 
ROM)	PROM 프로그램장치라는 특수장치를 이용하여 비어 있는 ROM에 사용자가 한번만 내용을 기입할 수 있으며, 이후엔 읽기만 가능함
EPROM
(Erasable PROM)	․자외선을 쏘여서 기입한 내용을 지울 수도 있고, PROM프로그램장치로 기입할 수도 있음
․사용자가 여러 번 반복해서 지우거나 기입할 수 있음
EAROM
(Erasable Alterable ROM)	전기적 특성을 이용하여 기록된 정보의 일부를 바꿀 수 있는 ROM
EEPROM
(Electronic EPROM)	전기적인 방법을 이용하여 기록된 내용을 여러 번 수정하거나 새로운 내용을 기록할 수 있는 ROM
	동적 램(DRAM)	정적 램(SRAM)
구성 소자	콘덴서	플립플롭
특징	전원이 공급되어도 일정 시간이 지나면 전하가 방전되므로 주기적인 재충전(Refresh)이 필요함	전원이 공급되는 동안에는 기억 내용이 유지됨
전력 소모	적음	많음
접근 속도	느림	빠름
집적도(밀도)	높음	낮음
가격	저가	고가
용도	일반적인 주기억장치	캐시 메모리
자기 
테이프	․순차처리(SASD)만 할 수 있는 대용량 저장매체
․가격이 저렴하고 용량이 커서 자료의 백업용으로 많이 사용함
․자성 물질이 코팅된 얇은 플라스틱 테이프를 동그란 릴에 감아 놓은 형태
․테이프의 시작과 끝부분을 알리는 은박지 사이의 정보 저장부분을 7～9 트랙으로 구성함
자기
디스크
(Magnetic 
Disk)	․자성 물질을 입힌 금속 원판을 여러 장 겹쳐서 만든 기억매체로 용량이 크고 접근 속도가 빠름
․순차, 비순차(직접) 처리가 모두 가능한 DASD(Direct Access Storage Device) 방식으로 데이터를 처리함
․트랙(Track) : 디스크 표면에서 회전축(스핀들 모터)을 중심으로 데이터가 기록되는 동심원
․섹터(Sector) : Track들을 일정한 크기로 구분한 부분이며, 정보 기록의 기본 단위임
․실린더(Cylinder) : 서로 다른 면들에 있는 동일 위치의 Track 들의 모임으로 실린더의 수는 한 면의 트랙 수와 동일함
자기드럼
(Magnetic Drum)	․원통 표면에 Track과 Sector를 구성하고, 각 Track마다 고정된 R/W Head를 두고 있어 자기디스크에 비해 속도가 빠름
․순차, 비순차(직접) 처리가 모두 가능한 DASD(Direct Access Storage Device) 방식으로 데이터를 처리함
․크기에 비해 용량이 적어 현재는 거의 사용하지 않음
IRG	논리
레코드	IRG	논리
레코드	IRG	논리
레코드	IRG	논리
레코드	IRG
IRG	논리
레코드	논리
레코드	논리
레코드	IRG	논리
레코드	논리
레코드	논리
레코드	IRG
연관기억
장치 
(Associative Memor y)	․기억장치에서 자료를 찾을 때 주소에 의해 접근하지 않고, 기억된 내용의 일부를 이용하여 Access할 수 있는 기억장치로 CAM(Content Addressable Memory)이라고도 함
․주소에 의해서만 접근이 가능한 기억장치보다 정보검색이 신속함 
․캐시메모리나 가상메모리관리 기법에서 사용하는 Mapping Table에 사용됨
․외부의 인자와 내용을 비교하기 위한 병렬 판독  논리 회로를 갖고 있기 때문에 하드웨어 비용이 증가함
복수 모듈 기억장치 
(Memory 
Interleaving)	․독자적으로 데이터를 저장할 수 있는 기억장치 모듈을 여러 개 가진 기억장치
․주기억장치와 CPU의 속도차의 문제점을 개선함 
․기억장치 버스를 시분할하여 사용함 
․기억장소의 접근을 보다 빠르게 함 
․복수 모듈 기억장치에 사용되는 각각의 기억장치는 자체의 어드레스 레지스터와 버퍼 레지스터를 가지고 독자적으로 데이터를 저장할 수 있음
․인터리빙 기법에 의해 기억장치를 구성하는 모듈 수만큼의 단어(Word)들에 동시 접근이 가능함
캐시 메모리
(Cache 
Memory)	․CPU의 속도와 메모리의 속도 차이를 줄이기 위해 사용하는 고속 Buffer Memory임
․캐시는 주기억장치와 CPU 사이에 위치함
․캐시 메모리는 메모리 계층 구조에서 가장 빠른 소자이며, 처리속도가 거의 CPU의 속도와 비슷할 정도임
․캐시를 사용하면 기억장치의 접근(access) 시간이 줄어듦으로 컴퓨터의 처리속도가 향상됨
․캐시는 수십 Kbyte～수백 Kbyte의 용량을 사용함 
가상기억장치
(Virtual 
Memory)	․기억용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용할 수 있도록 하는 운영체제의 메모리 운영 기법
․가상기억장치의 목적은 주기억장치의 용량 확보임
․가상 기억장치는 하드웨어적으로 실제로 존재하는 것이 아니고 소프트웨어적인 방법으로 보조기억 장치를 주기억장치처럼 사용하는 것임
․사용자 프로그램을 여러 개의 작은 블록으로 나누어서 보조기억장치 상에 보관해놓고 프로그램 실행시 필요한 부분들만 주기억장치에 적재함
․주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있음 
․가상기억장치 기법에서 사용하는 보조기억장치는 디스크 같은 DASD 장치이어야 함
