




▪정의 : 공통의 목적을 달성하기 위하여 여러 가지 상호 관련된 요소들을 유기적으로 결합한 것
▪특성 : 목적성, 자동성, 제어성, 종합성
▪기본 요소
입력(Input)	처리할 데이터, 처리 방법, 처리 조건을 시스템에 투입하는 것
처리(Process)	입력된 데이터를 처리 방법과 조건에 따라 처리하는 것
출력(Output)	처리된 결과를 시스템에서 산출하는 것
제어(Control)	자료가 입력되어 출력될 때까지의 처리 과정이 올바르게 행해지는지 감독하는 것
피드백
(Feedback)	출력된 결과가 예정된 목적을 만족시키지 못한 경우 목적 달성을 위해 반복 처리하는 것


▪시스템의 전반적인 흐름과 사용자들의 요구 사항을 파악하고 해결책을 마련하는 사람
▪기업의 목적과 현행 시스템의 문제점을 정확히 이해하고 해결책을 제시할 수 있어야 함
▪업무 내용이나 시스템에 대한 분석 능력이 있어야 함
▪컴퓨터 기술과 관리 기법을 알아야 함
▪시간 배정과 계획 등을 빠른 시간 내에 파악할 수 있어야 함
▪컴퓨터 하드웨어와 소프트웨어에 대한 전반적인 지식을 가져야 함
▪업계의 동향 및 관계 법규 등을 파악할 수 있어야 함
▪창조력, 응용력, 현장 분석 경험이 있어야 함
▪사용자와 프로그래머, 경영진 간의 의사소통을 원활히 하는 해결사 역할을 수행할 수 있어야 함


▪시스템을 개발하는 과정에서 공통적으로 반복되는 단계를 말하는 것
▪시스템 개발 생명 주기의 순서 : 시스템 조사 → 시스템 분석 → 시스템 설계 → 시스템 구현 → 테스트 → 시스템 운용 → 유지보수
▪T.M.Ho의 시스템 개발 주기 순서 : 상황 조사 → 현행 시스템의 연구 → 사용자 요구 사항 분석 → 대안 평가 → 새로운 하드웨어와 소프트웨어 선택 → 새 시스템의 설계 → 새 시스템의 구축 → 새 시스템의 인도
시스템 조사 	현행 시스템의 상태와 문제점을 파악하고 해결 방안을 제안하는 단계로, 예비 조사와 기초 조사로 나뉨
시스템 분석	조사 단계에서 조사된 사용자의 요구 사항과 현행 시스템의 문제점을 명확히 파악하여 요구 분석 명세서를 작성하는 과정으로, 기능 분석, 예비 설계, 비용 효과 분석 순으로 진행됨
시스템 설계	시스템 분석에 의해 정의된 시스템 요구 분석 명세서를 토대로 하여 새로운 시스템을 구체화하는 단계
․기본 설계 : 분석 결과에 따라 사용자 입장에서 시스템 전체를 개괄적으로 설계
․상세 설계 : 각 기능의 논리적인 절차를 확정하고, 구체적인 입․출력 내용 및 파일의 구체적인 내용의 사양을 결정하기 위한 단계
시스템 구현	설계 단계에서 산출된 설계 사양에 따라 프로그래밍 언어를 이용하여 원시코드를 작성하는 단계로, 프로그래밍(Programming) 또는 코딩(Coding)이라고도 함
테스트	사용자의 요구에 따라 시스템이 구현되었는지 검증하는 단계로, 테스트의 종류에는 통합 테스트, 시스템 테스트, 인수 테스트가 있음
시스템 운용(이행)	개발된 시스템을 실제 업무 처리에 적용하여 활용하는 단계
유지보수	․시스템 개발 단계 중 가장 많은 비용이 투입되는 단계
․종류 : 수정 유지보수, 적응 유지보수, 완전 유지보수, 예방 유지보수


▪코드란 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류․조합 및 집계를 용이하게 하고, 특정 자료의 추출을 쉽게 하기 위해서 사용하는 기호이다. 또한 어떤 단위별 수치를 알거나 파일을 체계화하기 위해서 사용된다.
▪코드의 기능
3대 기능	분류, 식별, 배열
그 밖의 기능	간소화, 표준화, 암호화, 단순화, 연상(표의성), 오류 검출,  구별, 추출
▪코드 설계 순서 : 코드화 대상 선정 → 코드화 목적의 명확화 → 코드 부여 대상 수 확인 → 사용 범위 결정 → 사용 기간 결정 → 코드화 대상의 특성 분석 → 코드 부여 방식의 결정 → 코드의 문서화
▪코드 설계시 유의 사항 : 기계 처리의 용이성, 취급의 용이성, 분류의 편리성(공통성, 체계성), 확장성, 단순성, 고유성, 표의성


▪순서 코드(Sequence Code) : 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법(순차 코드, 일련 번호식 코드)
▪구분 코드(Block Code) : 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련 번호를 부여하는 방법
▪그룹 분류식 코드(Group Classification Code) : 코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련 번호를 부여하는 방법
▪10진 코드(Decimal Code) : 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 코드로, 도서 정리를 목적으로 널리 사용함(도서 분류식 코드)
▪표의 숫자 코드(Significant Digit Code) : 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법(유효 숫자 코드)
▪연상 코드(Mnemonic Code) : 코드화 대상 항목의 명칭이나 약호와 관계 있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법(기호 코드)


▪필사 오류(Transcription Error) : 입력시 임의의 한 자리를 잘못 기록한 경우 발생(오자 오류)
▪전위 오류(Transposition Error) : 입력시 좌우 자리를 바꾸어 기록한 경우 발생
▪이중 오류(Double Transposition Error) : 전위 오류가 2개 이상 발생한 경우
▪생략 오류(Omission Error) : 입력시 한 자리를 빼놓고 기록한 경우 발생
▪추가 오류(Addition Error) : 입력시 한 자리를 더 추가하여 기록한 경우 발생
▪임의 오류(Random Error) : 위의 오류가 두 가지 이상 결합하여 발생한 경우


▪입력 설계 순서 : 입력 정보의 발생 → 입력 정보의 수집 → 입력 정보의 매체화 → 입력 정보의 투입 → 입력 정보의 내용
▪입력 매체 장치 선택시 검토 사항 : 시스템의 이행 방법 및 운용 비용, 입력 정보 발생 분야에서의 업무 특성, 입력 매체와 매체화 장치의 특성, 출력 정보를 이용할 시점에 맞게 투입
▪데이터 입력 방식
집중 매체화 시스템	발생한 데이터를 전표상에 기록하고, 일정 시간 단위로 일괄 수집하여 입력 매체에 수록하는 방식
분산 매체화 시스템	데이터를 발생한 장소에서 매체화하여 처리하는 방식
턴 어라운드 시스템	입력된 자료가 처리되어 일단 출력된 후 이용자를 경유하여 다시 재입력되는 방식으로, 공과금, 보험료 징수 등의 지로 용지를 처리하는 데 사용됨


▪빠르고, 정확하고, 쉽게 기입할 수 있어야 함
▪기입 항목은 가능한 한 적게 하고, 간단하게 적을 수 있어야 함
▪전표 번호나 발행 주문과 같은 고정 항목은 미리 인쇄하거나 선택할 수 있게 함
▪일정한 순서대로 기입할 수 있어야 함
▪혼란을 초래할 우려가 있는 것은 기입 요령을 명시함


▪출력 설계 순서 : 출력 정보의 내용 → 출력 정보의 매체화 → 출력 정보의 분배 → 출력 정보의 이용
출력 정보 내용에 대한 설계	출력할 항목과 명칭, 출력 항목의 배열 순서, 크기 자릿수, 출력 항목의 문자 표현 방법, 출력 항목에 대한 집계 방법, 출력 정보의 오류 검사 방법을 결정
출력 정보 매체화에 대한 설계	출력 형식. 출력 매체 및 장치, 출력 정보의 양과 출력 복사의 매수, 출력 장소와 출력 시기 및 주기, 출력 배열 순서를 결정
출력 정보 분배에 대한 설계	분배 책임자, 분배 방법 및 형태, 분배 경로, 분배 주기 및 시기에 대해 결정
출력 정보 이용에 대한 설계	출력 정보명과 출력 정보의 사용 목적, 출력 정보의 이용자와 이용 경로를 결정
▪COM 시스템 : 출력 정보를 마이크로필름에 수록하는 것으로, 축소 보관과 반영구적 보존이 가능하고, 지도, 설계 도면, 학적부, 변원의 기록 등을 보존, 건색, 관리하기에 적합한 방식


▪비블록화 고정 길이 레코드 : 하나의 논리 레코드를 그대로 전송하는 방식으로, 레코드의 수만큼 입․출력이 발생하므로 시간 낭비가 많고, 경제성이 좋지 않음
▪블록화 고정 길이 레코드 : 길이가 동일한 여러 개의 논리 레코드를 묶어 하나의 블록으로 구성한 형태로, 프로그램의 작성이 쉽고, 속도가 빠르며, 경제성이 좋음
▪비블록화 가변 길이 레코드 : 길이가 다른 하나의 논리 레코드를 그대로 전송하는 방식으로, 레코드의 길이 정보를 반드시 표시해야 하며, 프로그램의 작성이 어렵고, 시간 낭비되며, 경제성이 좋지 않음
▪블록화 가변 길이 레코드 : 길이가 서로 다른 여러 개의 논리 레코드를 묶어 하나의 블록으로 구성한 형태로, 각각의 레코드와 블록의 길이 정보를 반드시 표시해야 하며, 프로그램의 작성이 어렵지만 처리 속도가 빠르며, 경제성이 좋음


▪마스터 파일(Master File) : 전표 처리에서의 원장 또는 대장에 해당하는 파일로, 자료 관리의 중추적 역할을 담당하며 기본이 되는 파일임. 트랜잭션 파일에 의해 갱신됨
▪트랜잭션 파일(Transaction File) : 거래 내역이나 변동 내용 등 일시적인 성격을 지닌 정보를 기록하는 파일로, 마스터 파일을 갱신하거나 조회할 때 사용
▪요약 파일(Summary File) : 다른 파일의 중요 내용이나 합계를 용약해 높은 파일로, 집계용으로 많이 사용됨
▪히스토리 파일(History File) : 후일 통계 처리에 사용할 자료나 사고 발생시 마스터 파일 등을 원상 복구시키기 위한 자료를 보존한 파일


▪입력되는 데이터들을 논리적인 순서에 따라 물리적 연속 공간에 순차적으로 기록하는 방식으로, 주로 자기 테이프에 사용됨
▪급여 관리 등과 같이 변동 사항이 크지 않고 기간별로 일괄 처리를 주로 하는 경우에 적합함
▪기억 공간을 효율적으로 사용할 수 있음
▪매체 변환이 쉬워 어떠한 매체에도 적용할 수 있음
▪파일 중간에서 레코드를 삽입․삭제하는 경우 시간이 많이 소요됨
▪검색 효율이 낮음


▪순차 처리와 랜덤 처리가 모두 가능하도록 레코드들을 키값순으로 정렬하여 기록하고, 레코드의 키 항목만을 모은 인덱스를 구성하여 편성하는 방식
▪기본 데이터 구역 : 실제 레코드들을 기록하는 부분
▪인덱스 구역 : 기본 데이터 구역에 대한 인덱스가 기록되는 부분
트랙 
인덱스	기본 데이터 구역의 한 트랙에 기록되어 있는 데이터 레코드들 중의 최대 키 값과 주소가 기록되는 인덱스로, 한 실린더당 하나씩 만들어짐
실린더 
인덱스	각 트랙 인덱스의 최대 키 값과 해당 레코드가 기록된 실린더의 정보가 기록되는 인덱스로, 한 파일당 하나씩 만들어짐
마스터 
인덱스	실린더 인덱스 구역의 정보가 많을 경우 그것을 일정한 크기의 블록으로 구성하는데, 이때 처리할 레코드가 어느 실린더 인덱스에 기록되어 있는지를 기록하는 인덱스
▪오버플로 구역 : 기본 데이터 구역에 빈 공간이 없어서 새로운 레코드의 삽입이 불가능할 때를 대비하여 예비로 확보해 둔 구역


▪입력되는 정보를 기록 순서나 코드 순서와 같은 논리적 순서와 관계 없이 특정한 방법으로 키를 생성하여 임의의 위치에 보관하고 처리시에도 필요한 장소에 직접 접근할 수 있도록 편성하는 방식
▪처리하고자 하는 레코드를 주소 계산에 의하여 직접 처리할 수 있음
▪은행의 온라인 시스템과 같은 대화식 처리에 가장 효율적인 방식
▪접근 시간이 빠르고 레코드의 삽입, 삭제, 갱신이 용이
▪어떤 레코드라도 평균 접근 시간 내에 검색이 가능
▪충돌이 발생할 염려가 있으므로, 이를 위한 기억 공간의 확보가 필요
▪레코드의 주소 변환 과정을 위한 시간 필요
▪주소 계산 방법에는 직접 주소법과 디렉토리 조사법, 해싱 함수 이용법이 있음
▪해싱 함수 이용법 : 해싱은 해싱 함수를 이용하여 계산된 킷값(주소)에 해당하는 기억 공간에 레코드를 보관하거나 보관된 레코드를 검색하는 방법이다.              
해싱 함수	레코드의 키 값에서 레코드가 저장되어 있는 기억장치의 주소를 계산해 내는 사상 함수를 의미
버킷	하나의 주소를 가지는 영역을 의미하는 것으로, 하나의 버킷은 하나 이상의 레코드를 포함할 수 있음
충돌	두 개의 서로 다른 레코드가 같은 기억 공간(버킷)을 점유하려고 하는 현상
동거자(Synonym)	같은 주소를 갖는 레코드의 집합(유사어, 동의어)
▪해싱 함수 선택시 고려 사항 : 오버플로의 최소화, 충돌의 최소화, 계산 과정의 최소화(해싱 함수의 단순성), 키 변환 속도, 버킷의 속도


▪레코드들을 일정한 규칙이나 제약 없이 기억 공간에 자유롭게 기록하고, 각 레코드들은 다음 레코드의 주소를 가지고 있는 포인터를 통해 논리적인 순서로 연결됨
▪레코드는 데이터와 포인터로 구성되며, 포인터에는 다음 레코드의 주소가 저장됨
▪앞뒤의 포인터 내용만 변경하여 레코드를 쉽게 삽입․삭제할 수 있음
▪물리적으로 연속적인 공간을 확보하기 어려운 경우나 레코드의 수가 불규칙하게 변하는 경우에 효율적
▪포인터로 인해 레코드의 크기가 커지고, 예비 영역이 필요하므로, 기억 장소가 낭비됨


파일의 성격 검토 → 파일 항목의 검토 → 파일의 특성 조사 → 파일 매체의 검토 → 편성법 검토
파일의 성격 
검토	파일의 명칭, 작성 목적과 종류를 결정하고, 파일이 사용되는 적용 업무를 확인
파일 항목의 
검토 	항목의 명칭과 저장 형식, 항목의 배열 순서와 자리수, 레코드의 형식과 크기, 블록의 크기를 결정
파일의 특성 
조사 	효율적인 파일의 처리 형태와 처리 유형을 결정하고, 추가․수정․삭제의 발생 빈도와 처리 형태, 파일의 활동률을 확인
파일 매체의 
검토	․기능 검토 사항 : 액세스 형태와 처리 방식, 처리 시간과 정보의 양, 작동의 용이성을 검토
․종합 검토 사항 : 저장 매체와 매체의 개수, 장치의 대수를 결정
편성법 검토 	순차 편성, 랜덤 편성, 색인 순차 편성, 리스트 편성 등 파일의 편성 방식을 결정


▪신뢰성과 정확성을 고려하여 처리 과정을 간결하고 명확히 표현
▪오류에 대비한 검사 시스템을 고려
▪시스템의 상태 및 구성 요소, 기능 등을 종합적으로 표시
▪새로운 시스템의 프로세스 설계뿐만 아니라 기존 시스템의 문제점 분석이 가능하도록 설계
▪정보의 흐름이나 처리 과정을 모든 사람이 이해할 수 있도록 표준화
▪하드웨어와 프로그래머의 능력을 고려한다.
▪분류 처리는 가능한 적게 함
▪조작을 간결화, 자동화하여 사용자의 수동 조작을 적게 함


▪상태 및 구성 요소, 기능의 배열 순서와 총합 관계를 도형, 기호 등으로 표시한 것
▪블록 차트(Block Chart) : 업무를 개괄적으로 파악하는 데 사용
▪시스템 흐름도(System Flowchart) : 자료 발생부터 결과를 얻기까지 시스템의 전 과정을 나타내는 것
▪프로세스 흐름도(Process Flowchart) : 컴퓨터의 입력, 처리, 출력 과정을 그림으로 표시한 것으로, 오퍼레이터에게 처리 공정을 알려주고 컴퓨터의 전체적인 논리 구조의 파악, 컴퓨터의 사용 시간 계산 등에 사용됨
▪프로그램 흐름도(Program Flowchart) : 시스템 흐름도 중에서 컴퓨터 처리하는 부분을 중심으로 자료처리에 필요한 모든 조작 순서를 표시하는 것으로, 프로그램 전체의 내용을 개괄적으로 설명하는 개요 흐름도와 코딩, 데이터의 검토, 프로그램 기록 등을 위한 세부 사항을 기록하는 상세 흐름도가 있음


▪변환(Conversion) : 입력 매체 상의 데이터를 오류를 제거하고, 컴퓨터가 처리할 수 있는 형태로 편집하여 파일 매체로 변환(입력 변환)하고, 파일 매체에 저장된 내용을 사람이 확인할 수 있도록 출력 매체로 변환(출력 변환)하는 기능(매체 변환)
▪병합(Merge) : 동일한 파일 형식을 갖는 2개 이상의 파일을 일정한 규칙에 따라 하나의 파일로 통합 처리하는 기능
▪갱신(Update) : 마스터 파일의 내용을 변동 파일에 의해 추가, 삭제, 수정 등의 작업을 하여 새로운 내용의 마스터 파일을 생성하는 것
▪분배(Distribution) : 하나의 파일 안에서 조건에 맞는 것과 그렇지 않은 것을 분리하는 기능
▪추출(Extract) : 파일 안에서 특정 조건에 만족하는 데이터만을 골라내는 기능
▪조합(Collate) : 레코드 형식이 서로 다른 2개 이상의 파일에서 조건에 맞는 것을 골라 새로운 레코드로 파일을 만드는 기능


▪컴퓨터 입력 단계에서의 검사 방법 : 체크 디지트 검사, 공란 검사, 균형 검사, 형식 검사, 한계 검사(유효 범위 검사, 범위 검사), 일괄 합계 검사, 타당성 검사(논리 검사), 숫자 검사, 순차 검사(순서 검사), 대조 검사, 반향 검사, 데이터 수 검사
체크 디지트 검사
(Check Digit 
Check) 	코드를 설계할 때 본래의 코드에 검사할 수 있는 1자리의 숫자를 넣어줌으로써 컴퓨터에 의하여 자동으로 검사
균형 검사
(Balanced Check) 	차변과 대변의 한계값을 검사하는 방법으로, 대차의 균형이나 가로, 세로의 합계가 일치하는 가를 검사함
한계 검사(Limit 
Check) 	입력 데이터의 어떤 항목이 규정된 범위 내에 있는지를 검사
일괄 합계 검사
(Batch Total Check = Sum Check) 	입력 데이터의 특정 항목 합계값을 미리 계산해서 이것을 입력 데이터와 함께 입력하고, 컴퓨터상에서 계산한 결과값과 수동 계산 결과값이 같은지를 검사
데이터 수 검사
(Data Count 
Check) 	컴퓨터로 처리할 데이터의 개수를 미리 파악해 두었다가 컴퓨터로 처리한 데이터의 개수와 같은지 여부를 검사
▪계산 처리 단계에서의 검사 방법 : 부호 검사, 중복 레코드 검사, 불일치 레코드 검사, 오버플로 검사, 제로 균형 검사, 불능 검사



▪프로그래머의 업무 수행을 신속 정확하게 지원하는 작업 지시서의 역할을 하는 것
▪시스템 분석가(SA) 또는 시스템 엔지니어(SE)가 작성
▪프로그램 설계서의 구성 : 시스템명 및 코드명, 설계 방침, 프로세스 흐름도, 코드표, 입출력 설계표, 프로그래밍 지시서
▪프로그래밍 지시서의 구성 : 프로그램명, 설계서 작성자명, 프로그램의 작성 기간, 작성 비용, 작성 시기, 입출력 일람, 처리 개요, 처리 명세, 프로그램 작성 후 제출할 사항, 참고 자료


▪시스템의 평가 항목 : 기능 평가, 성능 평가, 신뢰성 평가
▪신뢰성 평가를 위한 검토 항목 : 시스템 전체의 가동률, 시스템을 구성하는 각 요소의 신뢰도, 신뢰성 향상을 위해 시행한 처리의 경제적 효과
▪시스템의 신뢰성 측정
MTBF(Mean Time Between Failures) 	평균 고장 간격. 수리가 가능한 시스템이 고장난 후부터 다음 고장이 날 때까지의 평균 시간
MTTF(Mean Time To Failures) 	평균 가동 시간. 수리 불가능한 시스템의 사용시점부터 고장이 발생할 때까지의 가동 시간 평균으로, 고장 평균 시간이라고도 함
MTTR(Mean Time To Repair) 	평균 수리 시간. 시스템에 고장이 발생하여 가동하지 못한 시간들의 평균
신뢰도(Availability, 가용도)	시스템의 총 운용 시간 중 정상적으로 가동된 시간의 비율


▪단위 테스트 : 각의 모듈에 대해 독립적인 환경에서 기본 데이터만 입력하여 테스트
▪통합 테스트 : 시스템 모듈간의 상호 인터페이스가 원활하게 수행되고 있는가를 확인하는 작업으로, 프로그램 단위별로 디버깅이 끝난 것을 모아 서로 연관된 프로그램군(Group)을 계통적으로 검사하며, 시스템 분석가에 의해 테스트 데이터가 작성됨(결합 테스트)
▪시스템 테스트 : 시스템이 초기의 목적을 만족시키는가를 확인하는 작업
▪인수 테스트 : 사용자의 요구 사항을 만족시키는가를 확인하는 작업으로, 개발 과정 이후에 사용자에게 인수하는 과정에서 수행함
▪테스팅 검토 : 테스트가 계획대로 수행되었는지를 확인하는 작업


▪시스템 개발팀에서 운용팀으로 인수인계가 용이
▪개발 후에 시스템의 유지보수가 용이
▪개발팀을 원활히 운용할 수 있음
▪시스템 개발 중의 추가 변경 또는 시스템의 개발 후의 변경에 따른 혼란을 방지할 수 있음
▪시스템 개발 방법과 순서를 표준화할 수 있어 효율적인 작업과 관리가 가능
▪복수 개발자에 의한 병행 개발을 가능하게 함
▪타업무 개발에 참고할 수 있음


▪전적(전통적) 생명 주기 모델로서, 폭포수에서 한번 떨어진 물이 거슬러 올라갈 수 없듯이 소프트웨어 개발도 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하며 이전 단계로 넘어 갈 수 없는 방식
▪가장 오랫동안 사용되어 온 모델로 적용 사례가 많음
▪단계별 정의가 분명하며, 각 단계별로 산출물이 명확히 나옴
▪새로운 요구 사항을 시스템에 반영하기가 어려움
▪개발 순서 : 타당성 조사 → 계획 → 요구 사항 분석 → 기본 설계(개략 설계) → 상세 설계 → 구현(Coding) → 통합 시험 → 시스템 실행 → 유지보수
타당성 조사	시스템의 정의와 가능성 조사 및 다른 방법과 비교 조사하는 단계
계획	사용자 문제의 정의, 전체 시스템 차원의 기본 목표와 요구 사항 결정, 추진 방안의 제시를 통해 시스템 개발 비용 및 소요 기간, 인력 등의 개발 계획을 수립하는 단계
요구 사항 
분석	소프트웨어에 요구되는 기능, 성능, 그리고 인터페이스 등 사용자의 요구 사항을 구체적으로 이해하는 단계
기본 설계
(=개략 설계)	개발될 소프트웨어에 대한 전체적인 하드웨어 및 소프트웨어 구조, 제어 구조, 자료 구조의 개략적인 설계를 작성하는 단계
상세 설계	각 단위 프로그램에 대한 사항을 상세히 기술하는 단계
구현 
(Coding)	설계 단계에서 만들어진 설계 사양서를 바탕으로 프로그램을 작성하는 단계로, 코딩과 디버깅, 단위 테스팅을 수행하는 단계
통합 시험	단위 프로그램별로 구현된 것을 통합시키며 시험하는 단계
시스템 실행	전체 시스템이 정확하게 실행하는가를 확인하는 단계
유지보수	시스템의 사용 중에 발생하는 여러 변경 사항에 대해 적응하고, 변화에 대비하는 과정


▪프로토타이핑 모델(Prototyping Model) : 사용자의 요구 사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 모형(Prototype, 시제품)을 만들어 의사 소통의 도구로 삼으면서 개발하는 기법
▪나선형 모델 : 폭포수 모델과 프로토타이핑의 장점에 위험 분석 기능을 추가한 모델(점증적 모델)
▪4세대 기법(4GH) : 자연어로 표현하는 4세대 언어를 이용하여 개발자가 조사한 요구 사항을 자동으로 구현(Coding)시키는 비절차적 기법


▪보기 쉽고 이해하기 쉬우며, 개발과 유지보수의 양면에서 경제적인 프로그램을 만들 수 있게 함
▪개발자의 생산성을 향상시킴
▪완성된 프로그램의 품질을 향상시켜 유지보수를 용이하게 함
▪프로그램의 표준화로 개인 격차를 해소하고, 개발 요원의 교대 근무를 용이하게 함


▪시스템 실행 과정인 입력, 처리, 출력을 계층적으로 기술하는 방법
▪시스템을 설계하거나 문서화하기 위한 도구임
▪체계화된 문서 작성이 가능하며, 보기 쉽고 알기 쉬움
▪하향식(Top-Down) 방식을 사용하여 나타냄
▪개발 과정에서 문서화를 부산물로 얻을 수 있음
▪도표상에 기능 위주로 입력 내용, 처리 방법, 출력 내용이 제시되므로 시스템의 이해가 쉬움
▪기능과 자료의 의존 관계를 동시에 표현할 수 있음
▪유지보수 및 변경이 용이함
▪HIPO의 구성
도식 목차
(Visual Table of Contents)	․HIPO에서 지정된 기능을 계층적으로 나타낸 도표
․시스템의 구조와 각 기능의 관계를 도식화한 것으로, 특정 기능을 쉽게 찾을 수 있음
총괄 도표
(Overview 
Diagram)	․시스템 또는 프로그램의 기능을 입력, 처리, 출력 관계로 도표화한 것
․사용자의 관점에서 본 시스템 또는 프로그램의 기능과 처리 내용을 나타내는 것
상세 도표
(Detail Diagram)	총괄 도표에 나타난 기능을 구성하는 기본 요소들을 상세히 기술한 도표


▪요구 분석 명세서를 작성하기 위하여 널리 사용되어 오는 IPT 기법 중의 하나임
▪구조적 분석은 도형 중심의 분석용 도구와 분석 절차를 이용하여 사용자의 요구 사항을 파악하고 문서화하는 체계적인 분석 기법임
▪구조적 분석용 도구 : 자료 흐름도(DFD), 자료 사전(DD), 소단위 명세서(Mini-Spec.), 개체 관계도(ERD), 상태 전이도(STD)
▪도형 중심의 문서화 도구를 사용함으로 분석자와 사용자간 대화가 용이
▪시스템을 하향식으로 세분화함
▪하향식 분할 원리를 적용하여 분석의 중복성을 배제함
▪사용자의 요구 사항을 논리적으로 표현하여 전체 시스템을 일관성 있게 이해할 수 있음


▪시스템의 처리 과정을 자료의 흐름에 중점을 두어 기술하는 분석용 도구로, 버블 차트라고도 함
▪하향식 분할의 원리를 적용하여 그림 중심으로 표현
▪자료 흐름도의 구성 요소
구성 요소	의미	표기법
처리	입력된 자료를 출력으로 변환하는 것	
자료 흐름	발생지, 종착지, 처리 및 저장소 사이에서 자료의 흐름을 나타냄	 →
자료 저장소	시스템 상의 자료를 저장하기 위한 장소	
단말	시스템에 필요한 자료가 입력되는 발생지와 시스템에서 처리된 자료가 출력되는 종착지를 나타냄	 


▪자료 흐름도의 대상의 되는 모든 자료에 대한 기본적인 사항들을 더 자세히 정의하기 위해 사용되는 도구로, 메타 데이터(Meta Data) 또는 데이터의 데이터라고도 함
▪이름을 이용해 정의를 쉽게 찾을 수 있어야 하며, 이름이 중복되어서는 안 됨
▪갱신하기 쉬워야 하며, 정의하는 방식이 명확해야 함
▪중복된 정의가 없어야 함
▪자료 사전의 정의 대상 : 자료 흐름(Data Flow)을 구성하는 자료 항목, 자료 저장소(Data Store)를 구성하는 자료 항목, 자료에 대한 의미, 자료 요소(Data Element)의 단위 및 값
▪자료 사전의 기호
기호	의미	기호	의미
=	자료의 정의	{  }	자료의 반복
+	자료의 연결	|	대체 항목의 나열
(  )	자료의 생략	* ... *	자료의 설명
[  ]	자료의 선택		


▪자료 흐름도상의 최하위 처리 절차를 상세하게 기술하는 데 사용하는 도구로, 프로세스 명세서라고도 함
▪구조적 언어, 의사 결정표, 의사 결정도를 이용하여 기술함


▪시스템에 어떤 일이 발생할 경우 시스템의 상태와 상태의 변화를 모델링하는 것
▪시스템의 행위를 정의하는 도구
▪시스템의 상태란 시스템이 수행 중인 상태를 의미하는 것으로 직사각형으로 나타냄
▪상태의 변화란 시스템이 어떤 상태에서 다른 상태로 변환되는 과정을 의미하는 것으로 화살표로 나타냄
▪상태의 변화를 일으키는 조건과 그 조건이 상태를 변화시킬 때 시스템이 취하는 행동을 제시해야 함
▪화살표의 시작은 상태 변화를 일으키는 사검을 의미하며, 화살표의 끝은 사건의 결과로 발생하는 조검임


▪프로그램의 제어 흐름을 선형화
▪단일 입구와 단일 출구만 가지게 함
▪GOTO 문은 사용하지 않음
▪구조화 이론의 세 가지 기본 논리 구조만을 사용함(순차, 선택(조건), 반복 구조)


▪두 모듈간의 상호 의존도를 측정하는 것으로, 좋은 설계는 모듈간의 결합도를 최소화하여 모듈의 독립성을 높인 것을 의미
▪결합도의 순서(약함 → 강함) : 자료 결합도 → 스탬프 결합도 → 제어 결합도 → 외부 결합도 → 공통 결합도 → 내용 결합도
자료 
결합도	서로 다른 모듈 간에 매개 변수 또는 인수를 통해 꼭 필요한 자료만을 교환하는 경우의 결합도로, 설계 품질이 가장 좋음
스탬프 
결합도	서로 다른 모듈이 동일한 자료 구조를 참조하는 경우의 결합도
제어 
결합도	서로 다른 모듈 간에 교환하는 매개 변수(Parameter)가 제어 정보인 경우의 결합도
외부 
결합도	어떤 모듈에서 외부(External)로 선언되어 있는 자료(변수)를 다른 모듈에서 참조하는 경우의 결합도
공통 
결합도	서로 다른 모듈들이 하나의 기억 장소에 설정된 공통의 데이터 영역을 공유하는 경우의 결합도
내용 
결합도	한 모듈이 다른 모듈의 내부 자료를 직접적으로 참조하는 경우의 결합도로, 결합도 중 의존도가 가장 높고, 순서 변경이 다른 모듈에 영향을 주기 쉬움



▪한 모듈 내에 있는 구성 요소의 기능적 관련성을 평가하는 기준으로서, 응집도가 높을수록 모듈의 독립성은 높아짐
▪응집도의 순서(약함 → 강함) : 기능적 응집도 → 순차적 응집도 → 통신적 응집도 → 절차적 응집도 → 시간적 응집도 → 논리적 응집도 → 우연적 응집도


▪데이터(속성)와 이를 처리하기 위한 연산(메소드)을 결합시킨 실체
▪객체마다 각각의 상태(State)를 가지고 있음
▪행위(Behavior)에 대한 특징을 나타냄
▪객체는 식별성을 가짐
▪모든 객체는 다른 객체들과 구별할 수 있는 이름을 가짐
▪일정한 기억 장소를 가지고 있음


▪속성(Attribute) : 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의하는 것으로서 성질, 분류, 식별, 수량 또는 현재 상태 등을 표현함
▪메소드(Method) : 객체에 정의된 연산을 의미하며, 객체의 상태를 참조하거나 변경하는 수단이 됨
▪클래스(Class) : 2개 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현하는 요소 즉, 공통된 특성과 행위를 갖는 객체의 집합이라고 할 수 있음. 한 클래스를 기준으로 하여 그 기준 클래스의 상위 클래스를 수퍼 클래스, 하위 클래스를 서브 클래스라고 함
▪인스턴스(Instance) : 하나의 클래스에 속하는 각각의 객체를 의미
▪인스턴스화(Instantiation) : 클래스로부터 새로운 객체를 생성하는 행위
▪메시지(Message) : 외부로부터 하나의 객체에 전달되는 메소드(행위)의 요구


▪주체성 : 다른 객체들과 식별할 수 있는 속성을 의미
▪분류성 : 동일 속성과 행위를 갖는 객체들을 하나의 클래스로 분류하는 속성을 의미
▪다형성 : 하나의 메시지에 대해 각 클래스가 가지고 있는 고유한 방법으로 응답할 수 있는 능력을 의미 즉, 같은 연산자라도 각 클래스에 따라 다른 기능을 수행할 수 있음
▪상속성(Inheritance) : 이미 정의된 상위 클래스의 메소드를 비롯한 모든 속성을 하위 클래스가 물려받을 수 있는 것을 의미
▪추상화(Abstraction) : 불필요한 부분을 생략하고 객체의 속성 중 가장 중요한 것에만 중점을 두어 개략화시키는 것을 의미
▪캡슐화(Encapsulation) : 데이터 구조와 데이터를 조작하는 연산을 하나로 묶어 하나의 모듈 내에서 결합되도록 하는 것을 의미
▪정보 은닉(Information Hidden) : 캡슐화된 정보를 외부에 감추는 것을 의미


▪객체 모델링 기법(OMT)이라고 하며 그래픽 표기법을 이용하여 모든 소프트웨어 구성 요소들의 객체를 모델링함
▪시스템의 무엇(객체 모델링)에서 언제(동적 모델링), 어떤 일(기능 모델링)이 일어나는가를 분석함
▪분석 절차 : 객체 모델링 → 동적 모델링 → 기능 모델링
객체 모델링
(Object Modeling)	실세계 문제 영역으로부터 시스템에 요구되는 객체를 찾아내어 객체들 간의 관계를 연관성, 집단화, 일반화 관계를 중심으로 정의하고 객체 다이어그램으로 나타내는 것
동적 모델링
(Dynamic 
Modeling)	시간의 흐름에 따라 변하는 객체들 사이의 제어 흐름, 상호 작용, 연산 순서 등의 동적인 행위를 상태 다이어그램으로 나타내는 것
기능 모델링
(Function Modeling)	다수 프로세스 간의 데이터 흐름을 중심으로 처리 과정을 데이터 흐름도로 나타내는 것


▪분석 기법 : E-R 다이어그램(개체 관계도)을 사용하여 개체의 활동들을 데이터 모델링하는 데 초점을 둔 기법
▪설계 기법 : 분석 사항을 하향식 방법으로 설계에 접근하여 프로토타입으로 개발하는 객체지향 설계 기법으로, 문제 영역 요소, 사람과 상호 작용 요소, 타스크(Task) 관리 요소, 데이터 관리 요소로 구성됨


▪1991년 Booch에 의해 발표된 객체지향 설계 기법으로, 설계 단계에 중점을 두어 클래스 및 객체의 식별과 그것들 간의 관계를 강조하였음
▪데이터 흐름도(DFD)를 사용해서 객체를 분해하고, 객체들 간의 인터페이스를 찾아 Ada 프로그램으로 변환시키는 기법
▪전체 시스템의 가시화와 실시간 처리(Real Time)에 유용
▪설계를 위한 문서화 기법을 강조함
▪분석 단계와 구현 세부 사항에 취약입력(Input)	처리할 데이터, 처리 방법, 처리 조건을 시스템에 투입하는 것
처리(Process)	입력된 데이터를 처리 방법과 조건에 따라 처리하는 것
출력(Output)	처리된 결과를 시스템에서 산출하는 것
제어(Control)	자료가 입력되어 출력될 때까지의 처리 과정이 올바르게 행해지는지 감독하는 것
피드백
(Feedback)	출력된 결과가 예정된 목적을 만족시키지 못한 경우 목적 달성을 위해 반복 처리하는 것
시스템 조사 	현행 시스템의 상태와 문제점을 파악하고 해결 방안을 제안하는 단계로, 예비 조사와 기초 조사로 나뉨
시스템 분석	조사 단계에서 조사된 사용자의 요구 사항과 현행 시스템의 문제점을 명확히 파악하여 요구 분석 명세서를 작성하는 과정으로, 기능 분석, 예비 설계, 비용 효과 분석 순으로 진행됨
시스템 설계	시스템 분석에 의해 정의된 시스템 요구 분석 명세서를 토대로 하여 새로운 시스템을 구체화하는 단계
․기본 설계 : 분석 결과에 따라 사용자 입장에서 시스템 전체를 개괄적으로 설계
․상세 설계 : 각 기능의 논리적인 절차를 확정하고, 구체적인 입․출력 내용 및 파일의 구체적인 내용의 사양을 결정하기 위한 단계
시스템 구현	설계 단계에서 산출된 설계 사양에 따라 프로그래밍 언어를 이용하여 원시코드를 작성하는 단계로, 프로그래밍(Programming) 또는 코딩(Coding)이라고도 함
테스트	사용자의 요구에 따라 시스템이 구현되었는지 검증하는 단계로, 테스트의 종류에는 통합 테스트, 시스템 테스트, 인수 테스트가 있음
시스템 운용(이행)	개발된 시스템을 실제 업무 처리에 적용하여 활용하는 단계
유지보수	․시스템 개발 단계 중 가장 많은 비용이 투입되는 단계
․종류 : 수정 유지보수, 적응 유지보수, 완전 유지보수, 예방 유지보수
3대 기능	분류, 식별, 배열
그 밖의 기능	간소화, 표준화, 암호화, 단순화, 연상(표의성), 오류 검출,  구별, 추출
집중 매체화 시스템	발생한 데이터를 전표상에 기록하고, 일정 시간 단위로 일괄 수집하여 입력 매체에 수록하는 방식
분산 매체화 시스템	데이터를 발생한 장소에서 매체화하여 처리하는 방식
턴 어라운드 시스템	입력된 자료가 처리되어 일단 출력된 후 이용자를 경유하여 다시 재입력되는 방식으로, 공과금, 보험료 징수 등의 지로 용지를 처리하는 데 사용됨
출력 정보 내용에 대한 설계	출력할 항목과 명칭, 출력 항목의 배열 순서, 크기 자릿수, 출력 항목의 문자 표현 방법, 출력 항목에 대한 집계 방법, 출력 정보의 오류 검사 방법을 결정
출력 정보 매체화에 대한 설계	출력 형식. 출력 매체 및 장치, 출력 정보의 양과 출력 복사의 매수, 출력 장소와 출력 시기 및 주기, 출력 배열 순서를 결정
출력 정보 분배에 대한 설계	분배 책임자, 분배 방법 및 형태, 분배 경로, 분배 주기 및 시기에 대해 결정
출력 정보 이용에 대한 설계	출력 정보명과 출력 정보의 사용 목적, 출력 정보의 이용자와 이용 경로를 결정
트랙 
인덱스	기본 데이터 구역의 한 트랙에 기록되어 있는 데이터 레코드들 중의 최대 키 값과 주소가 기록되는 인덱스로, 한 실린더당 하나씩 만들어짐
실린더 
인덱스	각 트랙 인덱스의 최대 키 값과 해당 레코드가 기록된 실린더의 정보가 기록되는 인덱스로, 한 파일당 하나씩 만들어짐
마스터 
인덱스	실린더 인덱스 구역의 정보가 많을 경우 그것을 일정한 크기의 블록으로 구성하는데, 이때 처리할 레코드가 어느 실린더 인덱스에 기록되어 있는지를 기록하는 인덱스
해싱 함수	레코드의 키 값에서 레코드가 저장되어 있는 기억장치의 주소를 계산해 내는 사상 함수를 의미
버킷	하나의 주소를 가지는 영역을 의미하는 것으로, 하나의 버킷은 하나 이상의 레코드를 포함할 수 있음
충돌	두 개의 서로 다른 레코드가 같은 기억 공간(버킷)을 점유하려고 하는 현상
동거자(Synonym)	같은 주소를 갖는 레코드의 집합(유사어, 동의어)
파일의 성격 
검토	파일의 명칭, 작성 목적과 종류를 결정하고, 파일이 사용되는 적용 업무를 확인
파일 항목의 
검토 	항목의 명칭과 저장 형식, 항목의 배열 순서와 자리수, 레코드의 형식과 크기, 블록의 크기를 결정
파일의 특성 
조사 	효율적인 파일의 처리 형태와 처리 유형을 결정하고, 추가․수정․삭제의 발생 빈도와 처리 형태, 파일의 활동률을 확인
파일 매체의 
검토	․기능 검토 사항 : 액세스 형태와 처리 방식, 처리 시간과 정보의 양, 작동의 용이성을 검토
․종합 검토 사항 : 저장 매체와 매체의 개수, 장치의 대수를 결정
편성법 검토 	순차 편성, 랜덤 편성, 색인 순차 편성, 리스트 편성 등 파일의 편성 방식을 결정
체크 디지트 검사
(Check Digit 
Check) 	코드를 설계할 때 본래의 코드에 검사할 수 있는 1자리의 숫자를 넣어줌으로써 컴퓨터에 의하여 자동으로 검사
균형 검사
(Balanced Check) 	차변과 대변의 한계값을 검사하는 방법으로, 대차의 균형이나 가로, 세로의 합계가 일치하는 가를 검사함
한계 검사(Limit 
Check) 	입력 데이터의 어떤 항목이 규정된 범위 내에 있는지를 검사
일괄 합계 검사
(Batch Total Check = Sum Check) 	입력 데이터의 특정 항목 합계값을 미리 계산해서 이것을 입력 데이터와 함께 입력하고, 컴퓨터상에서 계산한 결과값과 수동 계산 결과값이 같은지를 검사
데이터 수 검사
(Data Count 
Check) 	컴퓨터로 처리할 데이터의 개수를 미리 파악해 두었다가 컴퓨터로 처리한 데이터의 개수와 같은지 여부를 검사
MTBF(Mean Time Between Failures) 	평균 고장 간격. 수리가 가능한 시스템이 고장난 후부터 다음 고장이 날 때까지의 평균 시간
MTTF(Mean Time To Failures) 	평균 가동 시간. 수리 불가능한 시스템의 사용시점부터 고장이 발생할 때까지의 가동 시간 평균으로, 고장 평균 시간이라고도 함
MTTR(Mean Time To Repair) 	평균 수리 시간. 시스템에 고장이 발생하여 가동하지 못한 시간들의 평균
신뢰도(Availability, 가용도)	시스템의 총 운용 시간 중 정상적으로 가동된 시간의 비율
타당성 조사	시스템의 정의와 가능성 조사 및 다른 방법과 비교 조사하는 단계
계획	사용자 문제의 정의, 전체 시스템 차원의 기본 목표와 요구 사항 결정, 추진 방안의 제시를 통해 시스템 개발 비용 및 소요 기간, 인력 등의 개발 계획을 수립하는 단계
요구 사항 
분석	소프트웨어에 요구되는 기능, 성능, 그리고 인터페이스 등 사용자의 요구 사항을 구체적으로 이해하는 단계
기본 설계
(=개략 설계)	개발될 소프트웨어에 대한 전체적인 하드웨어 및 소프트웨어 구조, 제어 구조, 자료 구조의 개략적인 설계를 작성하는 단계
상세 설계	각 단위 프로그램에 대한 사항을 상세히 기술하는 단계
구현 
(Coding)	설계 단계에서 만들어진 설계 사양서를 바탕으로 프로그램을 작성하는 단계로, 코딩과 디버깅, 단위 테스팅을 수행하는 단계
통합 시험	단위 프로그램별로 구현된 것을 통합시키며 시험하는 단계
시스템 실행	전체 시스템이 정확하게 실행하는가를 확인하는 단계
유지보수	시스템의 사용 중에 발생하는 여러 변경 사항에 대해 적응하고, 변화에 대비하는 과정
도식 목차
(Visual Table of Contents)	․HIPO에서 지정된 기능을 계층적으로 나타낸 도표
․시스템의 구조와 각 기능의 관계를 도식화한 것으로, 특정 기능을 쉽게 찾을 수 있음
총괄 도표
(Overview 
Diagram)	․시스템 또는 프로그램의 기능을 입력, 처리, 출력 관계로 도표화한 것
․사용자의 관점에서 본 시스템 또는 프로그램의 기능과 처리 내용을 나타내는 것
상세 도표
(Detail Diagram)	총괄 도표에 나타난 기능을 구성하는 기본 요소들을 상세히 기술한 도표
구성 요소	의미	표기법
처리	입력된 자료를 출력으로 변환하는 것	
자료 흐름	발생지, 종착지, 처리 및 저장소 사이에서 자료의 흐름을 나타냄	 →
자료 저장소	시스템 상의 자료를 저장하기 위한 장소	
단말	시스템에 필요한 자료가 입력되는 발생지와 시스템에서 처리된 자료가 출력되는 종착지를 나타냄	 
기호	의미	기호	의미
=	자료의 정의	{  }	자료의 반복
+	자료의 연결	|	대체 항목의 나열
(  )	자료의 생략	* ... *	자료의 설명
[  ]	자료의 선택		
자료 
결합도	서로 다른 모듈 간에 매개 변수 또는 인수를 통해 꼭 필요한 자료만을 교환하는 경우의 결합도로, 설계 품질이 가장 좋음
스탬프 
결합도	서로 다른 모듈이 동일한 자료 구조를 참조하는 경우의 결합도
제어 
결합도	서로 다른 모듈 간에 교환하는 매개 변수(Parameter)가 제어 정보인 경우의 결합도
외부 
결합도	어떤 모듈에서 외부(External)로 선언되어 있는 자료(변수)를 다른 모듈에서 참조하는 경우의 결합도
공통 
결합도	서로 다른 모듈들이 하나의 기억 장소에 설정된 공통의 데이터 영역을 공유하는 경우의 결합도
내용 
결합도	한 모듈이 다른 모듈의 내부 자료를 직접적으로 참조하는 경우의 결합도로, 결합도 중 의존도가 가장 높고, 순서 변경이 다른 모듈에 영향을 주기 쉬움
객체 모델링
(Object Modeling)	실세계 문제 영역으로부터 시스템에 요구되는 객체를 찾아내어 객체들 간의 관계를 연관성, 집단화, 일반화 관계를 중심으로 정의하고 객체 다이어그램으로 나타내는 것
동적 모델링
(Dynamic 
Modeling)	시간의 흐름에 따라 변하는 객체들 사이의 제어 흐름, 상호 작용, 연산 순서 등의 동적인 행위를 상태 다이어그램으로 나타내는 것
기능 모델링
(Function Modeling)	다수 프로세스 간의 데이터 흐름을 중심으로 처리 과정을 데이터 흐름도로 나타내는 것
