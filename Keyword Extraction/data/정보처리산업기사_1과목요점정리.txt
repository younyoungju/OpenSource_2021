정보시스템 
▪조직체에 필요한 DATA를 수집, 저장해 두었다가 필요시에 처리해서 의사결정에 유용한 정보를 생성하고 분배하는 수단
▪사용하는 목적에 따라 경영정보 시스템, 군사 정보시스템, 인사 행정 정보 시스템, 의사 결정 지원 시스템 등으로 사용됨
정보와 자료
▪자료(Data) : 현실세계에서 관찰이나 측정을 통해 수집한 단순한 사실이나 결과값으로, 가공되지 않은 상태
▪정보(Information) : 의사 결정에 도움을 줄 수 있는 유용한 형태로, 자료를 가공(처리)해서 얻을 수 있는 결과
                   자료 처리 시스템
   자료  →                              →   정보

▪자료처리 시스템 : 정보시스템이 사용할 자료를 처리하는 정보 시스템의 서브시스템으로, 처리형태에 따라 일괄 처리 시스템, 온라인 실시간 처리 시스템, 분산 처리 시스템으로 분류됨
▪데이터 웨어 하우스(DataWare House) : 조직이나 기업체의 중심이 되는 주요 업무 시스템에서 추출되어 새로이 생성된 데이터베이스로서 의사결정지원 시스템을 지원하는 주체적, 통합적, 시간적 데이터의 집합체


▪통합된 데이터(Integrated data) : 자료의 중복을 배제한 데이터의 모임
▪저장된 데이터(Stored data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
▪운영 데이터(Operational data) : 조직의 업무를 수행하는데 있어서 존재 가치가 확실하고 없어서는 안 될 반드시 필요한 자료
▪공용 데이터 : 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료


▪실시간 접근성 : 수시적이고 비정형적인 질의(조회)에 대하여 실시간 처리(real time processing) 응답이 가능함
▪계속적인 변화 : 새로운 데이터의 삽입(insertion), 삭제(deletion),갱신(update)으로 항상 최신의 데이터를 유지함
▪동시 공용 : 여러 사용자가 동시에 자기가 원하는 데이터를 이용할 수 있음
▪내용에 의한 참조 : 데이터베이스에 있는 데이터를 참조할 때 데이터 주소나 위치에 의해서가 아니라 사용자가 요구하는 데이터 내용으로 데이터를 찾음


종속성으로 인한 문제점
▪종속성 : 응용프로그램과 데이터 파일이 상호 의존적인 관계
▪데이터 파일이 보조 기억 장치에 저장되는 방법이나 저장된 데이터의 접근 방법을 변경할 때는 응용프로그램도 같이 변경하여야함
중복성으로 인한 문제점
▪일관성 : 중복된 데이터간에 내용이 일치하지 않는 상황이 발생하여 일관성이 없어짐
▪보안성 : 중복되어 있는 모든 데이터에 동등의 보안수준을 유지하기가 어려움
▪경제성 : 저장 공간의 낭비와 동일한 데이터의 반복 작업으로 인한 비용의 증가
▪무결성 : 제어의 분산으로 인해 데이터의 정확성을 유지할 수 없음


▪정의(조직) : 데이터의 형(Type)과 구조, 데이터가 DB에 저장될 때의 제약조건 등을 명시하는 기능
▪조작 : 체계적 처리를 위한 데이터 접근 수단 등을 정하는 기능
▪제어 : 무결성, 보안 및 권한 검사, 병행수행 제어 등의 기능을 정하는 기능


장점
▪데이터의 중복을 피할 수 있음
▪저장된 자료를 공동으로 이용할 수 있음
▪데이터의 일관성을 유지할 수 있음
▪데이터의 무결성을 유지할 수 있음
▪보안을 유지할 수 있음
▪데이터를 표준화할 수 있음
▪데이터를 통합하여 관리할 수 있음
▪항상 최신의 데이터를 유지함
▪데이터의 실시간 처리가 가능함
▪데이터의 논리적 물리적 독립성이 보장됨
단점
▪데이터베이스 전문가 부족
▪전산화 비용이 증가함
▪대용량 디스크로의 집중적인 Access로 과부하(Overhead)가 발생함
▪파일의 예비(Backup)와 회복(Recovery)이 어려움
▪시스템이 복잡함


▪논리적 독립성 : 응용 프로그램과 데이터베이스를 독립시킴으로써, 데이터의 논리적 구조를 변경시키더라도 응용 프로그램은 변경되지 않음
▪물리적 독립성 : 응용 프로그램과 보조기억장치와 같은 물리적 장치를 독립시킴으로써, 데이터베이스 시스템의 성능 향상을 위해 새로운 디스크를 도입하더라도 응용 프로그램에는 영향을 주지 않고 데이터의 물리적 구조만을 변경함


▪데이터베이스의 구조와 제약조건에 관한 전반적인 명세(Specifica tion)를 기술(Description)함
▪데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작시 데이터 값들이 갖는 제약조건 등에 관해 전반적으로 정의함


외부 스키마(External Schema) = 서브 스키마 = 사용자 뷰(View)
▪사용자나 응용프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조 정의
▪전체 데이터베이스의 한 논리적인 부분으로 볼 수 있으므로 서브스키마(subschema)라고도 함
▪하나의 데이터베이스 시스템에는 여러 개의 외부 스키마가 존재할 수 있으며, 하나의 외부 스키마를 여러 개의 응용 프로그램이나 사용자가 공용할 수 있음
▪같은 데이터베이스에 대해서도 서로 다른 관점을 정의할 수 있도록 허용함
개념 스키마(Conceptual Schema) = 전체적인 뷰(View)
▪데이터베이스의 전체적인 논리적 구조로서 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재함
▪개념 스키마는 개체간의 관계와 제약조건을 나타내고 데이터베이스의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의함
▪단순히 스키마(schema)라고하면 개념 스키마를 의미함
▪기관이나 조직체의 관점에서 데이터베이스를 정의한 것임
내부 스키마(Internal Schema)  
▪데이터베이스의 물리적 구조
▪데이터의 실제 저장 방법 기술
▪물리적인 저장장치와 밀접한 계층
▪시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마


데이터 정의 언어(DDL; Data Definition Language)
▪DB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어
▪번역한 결과가 데이터사전(Data-dictionary)이라는 특별한 파일에 여러 개의 테이블로서 저장됨
▪데이터 정의 언의의 기능
․외부 스키마 명세 정의
․데이터베이스 정의 및 수정
․스키마에 사용되는 제약조건에 대한 명세 정의
․데이터의 물리적 순서 규정
데이터 조작 언어(DML; Data Manipulation Language) = 서브 언어
▪사용자로 하여금 데이터를 처리할 수 있게 하는 도구로서 사용자(응용프로그램)와 DBMS간의 인터페이스를 제공함
▪응용 프로그램을 통하여 사용자가 DB의 데이터를 실질적으로 조작할 수 있도록 하기 위해 FORTRAN, COBOL 등의 호스트 언어에 DB 기능을 추가시켜 만든 언어
▪대표적인 데이터 조작어(DML)에는 질의어가 있으며, 질의어는 터미널에서 주로 이용하는 비절차적(procedural) 데이터 언어임
데이터 제어 언어(DCL; Data Control Language)
▪무결성, 보안 및 권한 제어, 회복을 등을 하기 위한 언어
▪데이터를 보호하고 데이터를 관리하는 목적으로 사용됨
▪데이터 제어 언어의 기능 
․불법적인 사용자로부터 데이터를 보호하기 위한 데이터 보안(Secu rity)
․데이터 정확성을 위한 무결성(Integrity)유지
․시스템 장애에 대비한 데이터 회복과 병행 수행


데이터베이스 시스템의 모든 관리와 운영에 대한 책임을 지고 있는 사람이나 그룹
데이터베이스 설계와 조작에 대한 책임
▪데이터베이스 구성요소 결정
▪개념 스키마 및 내부스키마 정의
▪데이터베이스의 저장 구조 및 접근 방법 정의
▪보안 및 데이터베이스의 접근 권한 부여 정책 수립
▪장애에 대비한 예비(Back Up) 조치와 회복(Recovery)에 대한 전략 수립
▪무결성을 위한 제약 조건의 지정
▪데이터 사전의 구성과 유지관리
▪사용자의 변화 요구와 성능향상을 위한 데이터베이스의 재구성
행정책임
▪사용자의 요구와 불평의 청취 및 해결
▪데이터 표현 방법의 표준화
▪문서화에 대한 기준 설정
시스템 감시 및 성능분석
▪변화 요구에 대한 적응과 성능 향상에 대한 감시
▪시스템 감시 및 성능분석
▪자원의 사용도와 병목현상 조사
▪데이터 사용 추세, 이용 형태 및 각종 통계 등을 종합, 분석함


▪현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형임
▪현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계과정에서 데이터의 구조를 표현하기 위해 사용되는 도구임
▪데이터의 구조(Schema)를 논리적으로 묘사하기 위해 사용되는 지능적 도구임


개념적 데이터 모델 
▪속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현하는 방법
▪종류로는 E-R 모델이 있음
논리적 데이터 모델 
▪필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현하는 방법
▪단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미함
▪논리적 데이터베이스 모델은 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계모델, 계층모델, 네트워크 모델로 구분함


개체(Entity)
▪데이터베이스에 표현하려는 것으로 사람이 생각하는 개념이나 정보단위 같은 현실 세계의 대상체
▪유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 구성됨
▪파일 시스템의 레코드에 대응하는 것으로 어떤 정보를 제공하는 역할을 수행함
▪독립적으로 존재하거나 그 자체로서도 구별이 가능함
속성(Attribute)
▪데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당함
▪Entity를 구성하는 항목
                          속성

        교수번호	성명	전공	소속
144001	조성진	곤충	안산대
145002	박윤영	미생물	강원대
146001	강현준	식물	서울대
                        교수 개체
관계(Relationship)
▪Entity간의 관계 또는 Attribute간의 관계
▪위 그림의 관계는 교수가 학생을 지도하는 관계임 


▪개념적 데이터 모델의 가장 대표적인 것으로, 1976년 Peter Chen에 의해 제안됨
▪개체 타입(entity type)과 이들 간의 관계 타입(relationship type)을 이용해 현실 세계를 개념적으로 표현함
▪데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 묘사함
▪특정 DBMS를 고려한 것은 아님


기호		기호이름	의미
	사각형	개체(Entity) 타입
	다이아몬드	관계(Relationship) 타입
	타원	속성(Attribute)
	밑줄 타원	기본키 속성
	복수 타원	복합 속성
(예) 성명은 성과 이름으로 구성
	관계	1:1, 1:n, n:m 등의 개체 관계에 대해 선 위에 대응수 기술
  	선, 링크	개체타입과 속성을 연결


▪계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델
▪표(Table)를 이용해서 데이터 상호관계를 정의하는 DB 구조
▪데이터간의 관계를 기본키(primary key)와 이를 참조하는 외래키(foreign key)로 표현함
▪대표적인 언어 : Orcle, MS-SQL, Informix
▪1:1, 1:N, M:N 관계를 자유롭게 표현할 수 있음
▪장점 : 간결하고, 보기 편리하고, 다른 데이터베이스로의 변환이 용이함
▪단점 : 성능이 다소 떨어짐


▪데이터의 논리적 구조도가 트리 형태이며, 개체가 트리를 구성하는 노드 역할을 함
▪개체 집합에 대한 속성 관계를 표시하기 위해 개체를 노드로 표현하고 개체 집합들 사이의 관계를 링크로 연결함
▪개체간의 관계를 부모와 자식간의 관계로 표현함
▪개체 타입간에는 상위와 하위관계가 존재하며, 일 대 다(1:N) 대응관계만 존재함
▪레코드 삭제시 연쇄 삭제(Triggered Delete)가 됨 
▪개체 타입들간에는 사이클(cycle)이 허용되지 않음
▪계층형 모델에서는 개체(Entity)를 세그먼트(Segment)라 부름
▪대표적인 DBMS는 IMS임
▪관계의 유형
․속성 관계(Attribute Relation) : 세그먼트(개체)를 구성하는 속성들의 관계
  ․개체 관계(Entity Relation) : 개체와 개체간의 관계를 링크로 표시함


▪CODASYL이 제안한 것으로, CODASYL DBTG 모델이라고도 함
▪그래프를 이용해서 데이터 논리구조를 표현한 데이터 모델임
▪상위와 하위 레코드 사이에서 다 대 다(N:M) 대응관계를 만족하는 구조임
▪레코드 타입간의 관계는 1:1, 1:N, N:M이 될 수 있음
▪대표적 DBMS : DBTG, EDBS, TOTAL


요구분석	요구조건 명세서 작성
↓	
개념적 설계	개념 스키마, 트랜잭션 모델링, E-R 모델
↓	
논리적 설계	목표 DBMS에 맞는 스키마 설계
↓	
물리적 설계	목표 DBMS에 맞는 물리적 구조의 데이터로 변환
↓	
구현	특정 DBMS의 DDL로 데이터베이스 생성



▪1970년 IBM에 근무하는 E. F. Codd에 의해 처음 제안되었음
▪개체(Entity)나 관계(Relationship)를 모두 릴레이션(Relation)이라는 표(Table)로 표현함 
▪릴레이션은 개체를 표현하는 개체 릴레이션, 관계를 나타내는 관계 릴레이션으로 구분할 수 있음
▪장점 : 간결하고 보기 편리하며, 다른 데이터베이스로의 변환이 용이함
▪단점 : 성능이 다소 떨어진다.


데이터들을 표(Table)의 형태로 표현한 것으로 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성됨
<학생> 릴레이션
                            속성
   
         학번	이름	학년	신장	학과
89001	홍길동	2	170	CD
89002	이순신	3	169	CD
87012	임꺽정	2	180	ID
86032	장보고	4	174	ED
튜플(Tuple)
▪릴레이션을 구성하는 각각의 행
▪속성의 모임으로 구성됨
▪파일 구조에서 레코드와 같은 의미
속성(Attribute, 애트리뷰트)
▪데이터베이스를 구성하는 가장 작은 논리적 단위
▪파일 구조상의 데이터 항목 또는 데이터 필드에 해당됨
▪개체의 특성을 기술함
도메인(Domain)
▪하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(atomic) 값들의 집합
▪실제 애트리뷰트 값이 나타날 때 그 값의 합법여부를 시스템이 검사하는 데에도 이용됨
차수(Degree) : Attribute의 개수
기수(대응수; Cardinality) : Tuple의 개수


데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 애트리뷰트
후보키
(Candidate 
Key)	․릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용할 수 있는 속성들을 말함
․릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 함
기본키
(Primary 
Key)	․후보키 중에서 선택한 주키(Main Key)
․한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
․Null 값을 가질 수 없음
․기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없음

대체키
(Alternate 
Key)	․후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말함
․보조키라고도 함
슈퍼키
(Super Key)	․릴에이션에서 같은 튜플이 발생하지 않는 키를 구성할 때, 속성의 집합으로 구성하는 것을 말함
․릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함
외래키
(Foreign 
Key)	․관계(Realtionship)를 맺고 있는 릴레이션 R1, R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성
․외래키로 지정되면 참조테이블의 기본키에 없는 값은 입력할 수 없음
※ 널 값(NULL Value) : 데이터베이스에서 아직 알려지지 않거나 모르는 값으로서 "해당없음" 등의 이유로 정보 부재를 나타내기 위해 사용하는, 이론적으로 아무것도 없는 특수한 데이터


▪개체 무결성 : 릴레이션에서 기본키를 구성하는 속성은 널(NULL) 값이나 중복값을 가질 수 없음
  예) ‘학생’ 릴레이션에서 ‘학번’이 기본키로 정의 되면 튜플을 추가할 때 ‘주민번호’나 ‘성명’ 필드에는 값을 입력하지 않아도 되지만 ‘학번’ 속성에는 반드시 값이 입력되어야 함, 또한 ‘학번’ 속성에는 이미 한 번 입력한 속성 값을 중복하여 입력할 수 없음
▪참조 무결성 : 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함 즉, 릴레이션은 참조할 수 없는 외래키값을 가질 수 없음
  예) ‘수강’ 릴레이션의 ‘학번’ 속성에는 ‘학생’ 릴레이션의 ‘학번’ 속성에 없는 값은 입력할 수 없음


관계 데이터베이스에 적용할 수 있도록 특별히 개발한 관계 연산자
Select
▪릴레이션에 존재하는 튜플중에서 선택조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만듬
▪릴레이션의 행(가로)에 해당하는 퓨플을 구하는 것이므로 수평연산이라고도 함
▪연산자의 기호는 그리스문자 시그마(σ)를 사용함
▪표기 형식 : σ<조건>(R) 단, R은 릴레이션 이름
Project
▪주어진 릴레이션에서 속성 List에 제시된 Attribute만을 추출하는 연산
▪릴레이션의 열(세로)에 해당하는 Attribute을 추출하는 것이므로 수직 연산자라고도 함
▪연산자의 기호는 그리스문자 파이(π)를 사용함
▪표기 형식 : π<속성리스트>(R) 단, R은 릴레이션 이름
Join
▪공통 속성을 중심으로 2개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
▪연산자의 기호는 그리스문자 ▷◁를 사용함
▪표기 형식 : R ▷◁키속성r=키속성sS
  단, 키속성 r은 릴레이션 R의 속성이고, 키속성 s는 릴레이션 S의 속성임
Division
▪X ⊃ Y인 2개의 릴레이션에서 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산임
▪표기 형식 : R [속성r ÷ 속성s] S 
  단, 속성 r은 관계 R의 속성이고 속성 s는 관계 S의 속성이며, 속성 r과 속성 s는 동일 속성값을 가지는 속성이어야 함


이상(Anomaly) : 정규화(Normalization)를 거치지 않은 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작시 발생하는 예기치 못한 곤란한 현상
삽입 이상
(Insertion Anomaly)	릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상
삭제 이상
(Deletion Anomaly)	릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄 삭제 현상
갱신 이상
(Update Anomaly)	릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상


          비정규 릴레이션
                ↓ 도메인이 원자 값
               INF
                ↓ 부분적 함수 종속 제거
               2NF
                ↓ 이행적 함수 종속 제거
               3NF
                ↓ 결정자이면서 후보키가 아닌 것 제거
               BCNF
                ↓ 다치종속 제거
               4NF
                ↓ 조인 속성 이용
               5NF
       
정규화 단계 암기 요령
정규화라는 출소자가 말했다.
두부이겨다줘≒도부이결다조
도 메인이 원자값
부 분적 함수 종속 제거
이 행적 함수 종속 제거
결 정자이면서 후보키가 아닌 것 제거
다 치 종속 제거
조 인 종속성 이용


DDL(데이터 정의어)
▪SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용하는 언어
▪데이터베이스 관리자나 데이터베이스 설계자가 사용함
▪데이터 정의어(DDL)의 3가지 유형
명령어	기 능
CREATE	Schema, Domain, Table, View, Index를 정의함
ALTER	Table에 대한 정의를 변경하는 데 사용함
DROP	Schema, Domain,Table, View, Index를 삭제함
DML(데이터 조작어)
▪데이터베이스 사용자가 응용 프로그램이나 질의어를 통하여 저장된 데이터를 실질적으로 처리하는데 사용하는 언어
▪데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스 제공
▪데이터 조작어(DML)의 4가지 유형
명령어	기능
SELECT	테이블에서 조건에 맞는 튜플을 검색함
INSERT	테이블에 새로운 튜플을 삽입함
DELETE	테이블에서 조건에 맞는 튜플을 삭제함
UPDATE	테이블의 조건에 맞는 튜플의 내용을 변경함
DCL(데이터 제어어)
▪데이터의 보안, 무결성, 데이터 회복, 병행 수행 제어 등을 정의하는 데 사용하는 언어
▪데이터베이스 관리자가 데이터 관리를 목적으로 사용함
▪데이터 제어어(DCL)의 종류
명령어	기능
COMMIT	데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려줌
ROLLBACK	데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구함
GRANT	데이터베이스 사용자에게 사용권한을 부여함
REVOKE	데이터베이스 사용자의 사용권한을 취소함


테이블을 구성하는 튜플(행)들 중에서 전체 또는 조건을 만족하는 튜플(행)을 검색하여 주기억장치상에 임시 테이블로 구성시키는 명령문
일반 형식
SELECT predicate [테이블명.]속성명1, [테이블명.]속성명2,…
FROM 테이블명1, 테이블명2,… 
[WHERE 조건]
[GROUP BY 속성명1, 속성명2,…]
[HAVING 조건]
[ORDER BY 속성명 [ASC | DESC]];
① SELECT절
▪Predicate : 불러올 튜플수를 제한할 명령어를 기술함
․ALL : 모든 튜플을 검색할 때 지정하는 것으로, 주로 생략함
․DISTINCT : 중복된 튜플이 있으면 그 중 첫번째 한 개만 검색함
․DISTINCTROW : 중복된 튜플을 검색하지만 선택된 속성의 값이 아닌, 튜플 전체를 대상으로 함
▪속성명 : 검색하여 불러올 속성(열) 및 수식들을 지정함
․기본 테이블을 구성하는 모든 속성을 지정할 때는 '*' 를 기술함
․두 개 이상의 테이블을 대상으로 검색할 때는 반드시 테이블명.속성명으로 표현해야 함
② FROM절 : 질의에 의해 검색될 데이터들을 포함하는 테이블명을 기술함
③ WHERE절 : 검색할 조건을 기술
④ GROUP BY절 : 특정 속성을 기준으로 그룹화하여 검색할 때 그룹화 할 속성을 지정함. 일반적으로 GROUP BY절은 그룹함수와 함께 사용됨
⑤ HAVING절 : GROUP BY와 함께 사용되며, 그룹에 대한 조건을 지정함
⑥ ORDER BY절 : 특정 속성을 기준으로 정렬하여 검색할 때 사용함
▪속성명 : 정렬의 기준이 되는 속성명을 기술함
▪[ASC|DESC] : 정렬방식으로 ‘ASC'는 오름차순, ’DESC'는 내림차순임 생략하면 오름차순으로 지정됨


삽입문(Insert Into ～ )
INSERT
INTO 테이블명(속성명1, 속성명2,… )
VALUES (데이터1, 데이터2,… );
▪대응하는 속성과 데이터는 개수와 data_type이 일치해야 함
▪기본 테이블의 모든 속성을 사용할 때는 속성명을 생략할 수 있음
▪SELECT문을 사용하여 다른 테이블의 검색 결과를 삽입할 수 있음
삭제문 (Delete From ～ )
DELETE
FROM 테이블명
WHERE 조건;
▪모든 레코드를 삭제할 때는 WHERE절을 생략함
▪모든 레코드를 삭제하더라도 테이블 구조는 남아 있기 때문에 디스크에서 테이블을 완전히 제거하는 DROP과는 다름
갱신문 (Update ～ Set ～ )
UPDATE 테이블명
SET 속성명 = 데이터[, 속성명=데이터]
WHERE 조건;


▪내장 SQL : 응용 프로그램 내에 SQL문장을 내포하여 프로그램이 실행될 때 함께 실행되도록 호스트 프로그램 언어에 삽입된 SQL
▪내장 SQL 실행문은 호스트 언어에서 실행문이 나타날 수 있는 곳이면 프로그램의 어느 곳에서나 사용할 수 있음
▪일반 SQL문은 수행 결과로 여러 개의 튜플을 반환하는 반면, 내장 SQL은 단 하나의 튜플만을 반환함
▪내장 SQL문에 의해 반환되는 튜플은 일반 변수를 사용하여 저장할 수 있음
▪Host Program의 컴파일시 선행처리기에 의해 내장 SQL 문은 분리되어 컴파일됨
▪호스트 변수와 데이터베이스 필드의 이름은 같아도 됨
▪내장 SQL 문의 호스트 변수의 데이터 타입은 이에 대응하는 데이터베이스 필드의 SQL 데이터 타입과 일치하여야 함
▪삽입 SQL 문이 실행되면 SQL 실행의 상태가 SQL 상태 변수에 전달됨
▪호스트 언어의 실행문과 구분시키는 방법
․명령문의 구분
   - C/C++에서 내장 SQL문은 $와 세미콜론(;) 문자 사이에 기술함
   - Visual BASIC에서는 내장 SQL문 앞에 'EXEC SQL'을 기술함
․변수의 구분 : 내장 SQL에서 사용하는 호스트 변수는 변수 앞에 콜론(:) 문자를 붙임


▪시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스
▪데이터베이스에 포함되는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블
▪데이터 정의어의 결과로 구성되는 기본 테이블, 뷰, 인덱스, 패키지, 접근권한 등의 데이터베이스 구조 및 통계 정보를 저장함
▪카탈로그들이 생성되면 자료 사전(Data Dictionary)에 저장되기 때문에 좁은 의미로는 카탈로그를 자료사전이라고도 함
▪카탈로그에 저장된 정보를 메타 데이터(Meta-Data)라고 함
▪카탈로그의 특징
․카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 이용자도 SQL을 이용하여 내용을 검색해 볼 수 있음
․INSERT, DELETE, UPDATE문으로 갱신하는 것은 허용하지 않음
․DBMS가 스스로 생성하고, 유지함
․카탈로그는 사용자가 SQL문을 실행시켜 기본 테이블, 뷰, 인덱스 등에 변화를 주면 시스템이 자동으로 갱신함


▪사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블
▪권한이 있는 상태로 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주됨
▪뷰(View)의 특징
․기본 테이블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를 가지며, 조작도 기본 테이블과 거의 같음
․가상 테이블이기 때문에 물리적으로 구현되어 있지 않음
․필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해짐
․뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있음
․기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야만 삽입, 삭제, 갱신 연산이 가능함
․정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있음
․하나의 뷰를 삭제하면 그 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨
▪뷰의 장점
․논리적 데이터 독립성을 제공함
․동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해줌
․사용자의 데이터 관리를 간단하게 해줌
․접근제어를 통한 자동 보안이 제공됨
▪뷰의 단점
․독립적인 인덱스를 가질 수 없음
․뷰의 정의를 변경할 수 없음
․뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름


▪선형구조 : 선형리스트, 연결리스트, 스택, 큐, 데크
▪비선형 구조 : 트리, 그래프


▪리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료구조
▪가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO; Last-In, First-Out) 방식으로 자료를 처리함
▪TOP :  Stack으로 할당된 기억공간에 가장 마지막으로 삽입된 자료가 기억된 공간을 가리키는 요소, 스택 포인터라고도 함
▪Bottom : 스택의 가장 밑바닥임
▪Stack의 용도
․부프로그램 호출시 복귀주소를 저장할 때
․인터럽트가 발생하여 복귀주소를 저장할 때 
․후위표기법(Postfix Notation)으로 표현된 산술식을 연산할 때 
․0 주소 지정방식 명령어의 자료저장소
․재귀(RECURSIVE)프로그램의 순서제어
․컴파일러를 이용한 언어번역시


▪선형 리스트의 한쪽에서는 삽입작업이 이루어지고 다른 쪽에서는 삭제작업이 이루어지도록 구성한 자료구조
▪가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO; First-In, First-Out) 방식으로 처리함
▪Queue를 이용하는 예
․창구업무처럼 서비스 순서를 기다리는 등의 대기행렬의 처리에 사용함
․운영체제의 작업 스케줄링에 사용함


▪삽입과 삭제가 리스트의 양쪽 끝에서 모두 발생할 수 있는 자료구조
▪Stack과 Queue의 장점만 따서 구성한 것임
▪입력이 한쪽에서만 발생하고 출력은 양쪽에서 일어날 수 있는 입력제한과, 입력은 양쪽에서 일어나고 출력은 한곳에서만 이루어지는 출력제한이 있음
▪입력 제한 데크 : Scroll
▪출력 제한 데크 : Shelf



▪노드(Node) : 하나의 자료항목과 다른 항목에 대한 가지(Branch)를 합친 것
  (예) A, B, C, D, E, F, G, H, I, J, K ,K, M
▪근노드(Root Node) : 트리의 맨 위에 있는 노드  (예) A
▪디그리(Degree, 차수) : 각 노드에서 뻗어 나온 가지의 수
  (예) A=3, B=2, C=1, D=3
▪트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수
  (예) 노드 A나 D가 3개의 디그리를 가지므로 위 트리의 디그리는 3임
▪단말노드(Terminal Node)=잎노드(Leaf Node) : 자식이 하나도 없는 노드, 즉 Degree가 0인 노드 
  (예) K, L, F, G, M, I, J
▪비단말 노드(Non-Terminal Node) : 자식이 하나라도 있는 노드, 즉 Degree가 0이 아닌 노드 
  (예) A, B, C, D, E, H
▪자노드(Son Node) : 어떤 노드에 연결된 다음 레벨의 노드들
  (예) D의 자노드 : H, I, J
▪부노드(Parent Node) : 어떤 노드에 연결된 이전 레벨의 노드
  (예) E, F의 부도는 B
▪형제노드(Brother Node, Sibling) : 동일한 부모를 갖는 노드들
  (예) H의 형제노드는 I, J
▪Level : 근노드의 Level을 1로 가정한 후 어떤 Level이 L이면 자식노드는 L+1
  (예) H의 레벨은 3
▪깊이(Depth, Height) : 어떤 Tree에서 노드가 가질 수 있는 최대의 레벨
  (예) 위 트리의 깊이는 4


                      
▪Preorder 운행 : Root → Left → Right 순으로 운행함 A B C
▪Inorder 운행 : Left → Root → Right 순으로 운행함 B A C
▪Postorder 운행 : Left → Right → Root 순으로 운행함 B C A 
  (예) 다음 트리를 Inorder, Preorder, Postorder 방법으로 운행했을 때 각 노드를 방문한 순서는?
   
▪Preorder 운행법의 방문순서

서브 트리를 하나의 노드로 생각할 수 있도록 위 그림과 같이 서브 트리단위로 묶습니다. Preorder, Inorder, Postorder 모두 공통으로 사용함
․Preorder는 Left → Root → Right이므로 A13이 됨
․1은 B2E이므로 AB2E3이 됨
․2는 DHI이므로 ABDHIE3이 됨
․3은 CFG이므로 ABDHIECFG가 됨   방문순서 : ABDHIECFG
▪Inorder 운행법의 방문순서
․Inorder는 Left → Root → Right 이므로 1A3이 됨 
․1은 2BE이므로 2BEA3이 됨
․2는 HDI이므로 HDIBEA3이 됨
․3은 FCG이므로 HDIBEAFCG가 됨  방문순서 : HDIBEAFCG
▪Postorder
․Postorder는 Left → Right → Root이므로 13A가 됨
․1은 2EB이므로 2EB3A가 됨
․2는 HID이므로 HIDEB3A가 됨
․3은 FGC이므로 HIDEBFGCA가 됨  방문순서 : HIDEBFGCA


                
▪전위표기법(PreFix) : 연산자 → Left → Right, +AB
▪중위표기법(InFix) : Left → 연산자 → Right, A+B
▪후위표기법(PostFix) : Left → Right → 연산자, AB+


▪내부정렬
․소량의 데이터에 대하여 주기억장치 내에만 기억시켜서 정렬하는 방식
․종류 : 히프정렬, 삽입정렬, 버블정렬, 선택정렬, 퀵정렬, 2-Way Merge Sort, 기수정렬(=Radix Sort)
▪외부정렬
․대량의 데이터에 대하여 보조기억장치에 기억시켜서 정렬하는 방식으로, 대부분 합병정렬(Merge Sort) 기법으로 처리 
․종류 : 밸런스 병합정렬, 캐스캐이드 병합정렬, 폴리파즈 병합정렬, 오실레이팅 병합정렬


▪Hash Table이라는 기억공간을 할당하고, 해시함수(Hash Function)를 이용하여 레코드 키에 대한 Hash Table 내의 Home Address를 계산한 후 주어진 레코드를 해당 기억장소에 저장하거나 검색작업을 수행하는 방식
▪DAM(직접접근) 파일을 구성할 때 해싱이 사용되며, 접근 속도는 빠르나 기억공간이 많이 요구됨
▪검색 속도가 가장 빠름
▪삽입, 삭제 작업의 빈도가 많을 때 유리한 방식
▪해시 테이블(Hash Table) 
․레코드를 1개 이상 보관할 수 있는 Home Bucket들로 구성한 기억공간으로, 보조기억장치에 구성할 수도 있고 주기억장치에 구성할 수도 있음

․버킷(bucket) : 하나의 주소를 갖는 파일의 한 구역을 의미하며, 버킷의 크기는 같은 주소에 포함될 수 있는 레코드 수를 의미함
․슬롯(slot) : 한 개의 레코드를 저장할 수 있는 공간으로 n개의 슬롯이 모여 하나의 버킷을 형성함
․Collision(충돌현상) : 서로 다른 두 개 이상의 레코드가 같은 주소를 갖는 현상
․Synonym : 같은 Home Address를 갖는 레코드들의 집합
․Overflow : 계산된 Home Address의 Bucket 내에 저장할 기억공간이 없는 상태(Bucket을 구성하는 Slot이 여러 개일 때는 Collisi on은 발생해도 Overflow는 발생하지 않을 수 있음)


▪입력되는 데이터들을 논리적인 순서에 따라 물리적 연속 공간에 순차적으로 기록하는 방식
▪급여 관리 등과 같이 변동 사항이 크지 않고 기간 별로 일괄 처리를 주로 하는 경우에 적합함
▪주로 순차 접근이 가능한 자기 테이프에서 사용됨 
▪순차 파일의 장점
․기록 밀도가 높아 기억 공간을 효율적으로 사용할 수 있음
․매체 변환이 쉬워 어떠한 매체에도 적용할 수 있음
․레코드를 기록할 때 사용한 키 순서대로 레코드를 처리하는 경우, 다른 편성법보다 처리 속도가 빠르다.
▪순차 파일의 단점
․파일에 새로운 레코드를 삽입․삭제하는 경우 파일 전체를 복사해야 하므로 시간이 많이 소요됨
․데이터 검색시 처음부터 순차적으로 하기 때문에 검색 효율이 낮음


▪순차 처리와 랜덤 처리가 모두 가능하도록 레코드들을 키 값순으로 정렬(Sort)시켜 기록하고, 레코드의 키 항목만을 모은 색인을 구성하여 편성하는 방식
▪색인을 이용한 순차적인 접근 방법을 제공하여 ISAM(Index Sequent ial Access Method)라고도 함
▪레코드를 참조하는 경우 색인을 탐색한 후 색인이 가리키는 포인터(주소)를 사용하여 직접 참조할 수 있음
▪일반적으로 자기 디스크에 많이 사용되며, 자기 테이프에서는 사용할 수 없음
▪색인 순차 파일의 구성
․기본 구역(Prime Area) : 실제 레코드들을 기록하는 부분으로, 각 레코드는 키 값순으로 저장됨
․색인 구역(Index Area) : 기본 구역에 있는 레코드들의 위치를 찾아가는 색인이 기록되는 부분으로, 트랙 색인 구역, 실린더 색인 구역, 마스터 색인 구역으로 구분할 수 있음
․오버플로우 구역(Overflow Area) : 기본 구역에 빈 공간이 없어서 새로운 레코드의 삽입이 불가능할 때를 대비하여 예비적으로 확보해둔 부분임
실린더 오버플로우 
구역(Cylinder 
Overflow Area)	각 실린더마다 만들어지는 오버플로우 구역으로, 해당 실린더의 기본 구역에서 오버플로우된 데이터를 기록함
독립 오버플로우 구역(Independent 
Overflow Area)	실린더 오버플로우 구역에 더 이상 오버플로우된 데이터를 기록할 수 없을 때 사용할 수 있는 예비 공간으로, 실린더 오버플로우 구역과는 별도로 만들어진다.


▪동적 인덱스 방법을 이용한 색인 순차 파일
▪제어 구간, 제어 구역, 순차 세트, 인덱스 세트로 구성됨
제어 구간(Control Interval) 	데이터 레코드가 저장되는 부분
제어 구역(Control Area) 	몇 개의 제어 구간을 모아놓은 것
순차 세트(Sequence Set) 	제어 구역에 대한 인덱스를 저장한 것
인덱스 세트(Index Set) 	순차 세트의 상위 인덱스
▪기본 구역과 오버플로우 구역을 구분하지 않음
▪레코드를 삭제하면 그 공간을 재사용할 수 있음
▪제어 구간에 가변 길이 레코드를 쉽게 수용할 수 있음교수번호	성명	전공	소속
144001	조성진	곤충	안산대
145002	박윤영	미생물	강원대
146001	강현준	식물	서울대
기호		기호이름	의미
	사각형	개체(Entity) 타입
	다이아몬드	관계(Relationship) 타입
	타원	속성(Attribute)
	밑줄 타원	기본키 속성
	복수 타원	복합 속성
(예) 성명은 성과 이름으로 구성
	관계	1:1, 1:n, n:m 등의 개체 관계에 대해 선 위에 대응수 기술
  	선, 링크	개체타입과 속성을 연결
요구분석	요구조건 명세서 작성
↓	
개념적 설계	개념 스키마, 트랜잭션 모델링, E-R 모델
↓	
논리적 설계	목표 DBMS에 맞는 스키마 설계
↓	
물리적 설계	목표 DBMS에 맞는 물리적 구조의 데이터로 변환
↓	
구현	특정 DBMS의 DDL로 데이터베이스 생성
학번	이름	학년	신장	학과
89001	홍길동	2	170	CD
89002	이순신	3	169	CD
87012	임꺽정	2	180	ID
86032	장보고	4	174	ED
후보키
(Candidate 
Key)	․릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용할 수 있는 속성들을 말함
․릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 함
기본키
(Primary 
Key)	․후보키 중에서 선택한 주키(Main Key)
․한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
․Null 값을 가질 수 없음
․기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없음
대체키
(Alternate 
Key)	․후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말함
․보조키라고도 함
슈퍼키
(Super Key)	․릴에이션에서 같은 튜플이 발생하지 않는 키를 구성할 때, 속성의 집합으로 구성하는 것을 말함
․릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함
외래키
(Foreign 
Key)	․관계(Realtionship)를 맺고 있는 릴레이션 R1, R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성
․외래키로 지정되면 참조테이블의 기본키에 없는 값은 입력할 수 없음
삽입 이상
(Insertion Anomaly)	릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상
삭제 이상
(Deletion Anomaly)	릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄 삭제 현상
갱신 이상
(Update Anomaly)	릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상
          비정규 릴레이션
                ↓ 도메인이 원자 값
               INF
                ↓ 부분적 함수 종속 제거
               2NF
                ↓ 이행적 함수 종속 제거
               3NF
                ↓ 결정자이면서 후보키가 아닌 것 제거
               BCNF
                ↓ 다치종속 제거
               4NF
                ↓ 조인 속성 이용
               5NF
명령어	기 능
CREATE	Schema, Domain, Table, View, Index를 정의함
ALTER	Table에 대한 정의를 변경하는 데 사용함
DROP	Schema, Domain,Table, View, Index를 삭제함
명령어	기능
SELECT	테이블에서 조건에 맞는 튜플을 검색함
INSERT	테이블에 새로운 튜플을 삽입함
DELETE	테이블에서 조건에 맞는 튜플을 삭제함
UPDATE	테이블의 조건에 맞는 튜플의 내용을 변경함
명령어	기능
COMMIT	데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려줌
ROLLBACK	데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구함
GRANT	데이터베이스 사용자에게 사용권한을 부여함
REVOKE	데이터베이스 사용자의 사용권한을 취소함
SELECT predicate [테이블명.]속성명1, [테이블명.]속성명2,…
FROM 테이블명1, 테이블명2,… 
[WHERE 조건]
[GROUP BY 속성명1, 속성명2,…]
[HAVING 조건]
[ORDER BY 속성명 [ASC | DESC]];
INSERT
INTO 테이블명(속성명1, 속성명2,… )
VALUES (데이터1, 데이터2,… );
DELETE
FROM 테이블명
WHERE 조건;
UPDATE 테이블명
SET 속성명 = 데이터[, 속성명=데이터]
WHERE 조건;
실린더 오버플로우 
구역(Cylinder 
Overflow Area)	각 실린더마다 만들어지는 오버플로우 구역으로, 해당 실린더의 기본 구역에서 오버플로우된 데이터를 기록함
독립 오버플로우 구역(Independent 
Overflow Area)	실린더 오버플로우 구역에 더 이상 오버플로우된 데이터를 기록할 수 없을 때 사용할 수 있는 예비 공간으로, 실린더 오버플로우 구역과는 별도로 만들어진다.
제어 구간(Control Interval) 	데이터 레코드가 저장되는 부분
제어 구역(Control Area) 	몇 개의 제어 구간을 모아놓은 것
순차 세트(Sequence Set) 	제어 구역에 대한 인덱스를 저장한 것
인덱스 세트(Index Set) 	순차 세트의 상위 인덱스
