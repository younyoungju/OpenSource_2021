



▪제어 프로그램(Control Program) : 시스템 전체의 작동 상태 감시, 작업의 순서 지정, 작업에 사용되는 데이터 관리 등의 역할을 수행하는 프로그램
감시(Supervisor) 프로그램	각종 프로그램의 실행과 시스템 전체의 작동 상태를 감시․감독하는 프로그램
작업 제어(Job Control) 프로그램	어떤 업무를 처리하고 다른 업무로의 이행을 자동으로 수행하기 위한 준비 및 그 처리에 대한 완료를 담당하는 프로그램
자료 관리(Data Management) 프로그램	주기억장치와 보조기억장치 사이의 데이터 전송과 보조기억장치의 자료 갱신 및 유지 보수 기능을 수행하는 프로그램
▪처리 프로그램 : 제어 프로그램의 지시를 받아 사용자가 요구한 문제를 해결하기 위한 프로그램
언어 번역(Language Translate)  프로그램	원시 프로그램을 기계어 형태의 목적 프로그램으로 번역하는 프로그램(어셈블러, 컴파일러, 인터프리터)
서비스(Service) 프로그램	컴퓨터를 효율적으로 사용할 수 있는 사용 빈도가 높은 프로그램
문제(Problem) 프로그램	특정 업무 및 해결을 위해 사용자가 작성한 프로그램


정의	컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
목적	․사용자와 컴퓨터 간의 인터페이스 제공
․자원의 효율적인 운영 및 자원 스케줄링
․데이터 공유 및 주변 장치 관리
․처리 능력 및 신뢰도 향상, 사용 가능도 향상
․응답(반응) 시간 단축, 반환 시간 등의 단축
기능	․프로세서, 기억장치, 입․출력장치, 파일 및 정보 등의 자원 관리
․자원의 스케줄링 기능 제공
․사용자와 시스템 간의 편리한 인터페이스 제공
․시스템의 각종 하드웨어와 네트워크 관리․제어
․시스템의 오류 검사 및 복구, 데이터 관리, 데이터 및 자원 공유
․자원 보호 기능 제공
․가상 계산기 기능 제공


▪일괄 처리(Batch Processing) 시스템 : 초기의 컴퓨터 시스템에서 사용된 형태로, 일정량 또는 일정 기간 동안 데이터를 모아서 한꺼번에 처리하는 방식
▪다중 프로그래밍(Multi Programming) 시스템 : 하나의 CPU와 주기억장치를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식
▪시분할(Time Sharing) 시스템 : 여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리해줌으로써 각 사용자에게 각자 독립된 컴퓨터를 사용하는 느낌을 주는 방식(라운드 로빈 방식)
▪다중 처리(Multi Processing) 시스템 : 여러 개의 CPU와 하나의 주기억장치를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식
▪실시간 처리(Real Time Processing) 시스템 : 데이터 발생 즉시, 또는 데이터 처리 요구가 있는 즉시 처리하여 결과를 산출하는 방식
▪다중 모드 처리(Multi Mode Processing) : 일괄 처리 시스템, 시분할 시스템, 다중 처리 시스템, 실시간 처리 시스템을 한 시스템에서 모두 제공하는 방식
▪분산 처리(Distributed Processing) 시스템 : 여러 개의 컴퓨터(프로세서)를 통신 회선으로 연결하여 하나의 작업을 처리하는 방식
▪발달 과정 : 일괄 처리 시스템 → 다중 프로그래밍, 다중 처리, 시분할, 실시간 처리 시스템 → 다중 모드 → 분산 처리 시스템


컴파일러	․고급 언어로 작성된 프로그램 전체를 목적 프로그램으로 번역한 후, 링킹 작업을 통해 컴퓨터에서 실행 가능한 실행 프로그램 생성
․번역 과정이 번거롭고, 번역 시간이 오래 걸리지만 실행 속도가 빠름
․FORTRAN, COBOL, PASCAL, C, C++, PL/1 등이 컴파일러를 사용함
인터프리터	․고급 언어로 작성된 프로그램을 한 줄 단위로 받아들여  번역하고, 번역과 동시에 프로그램을 한 줄 단위로 즉시 실행시키는 프로그램
․줄 단위로 번역․실행되기 때문에 시분할 시스템에 유용함
․프로그램이 직접 실행되므로 목적 프로그램이 생성되지 않음
․번역 속도는 빠르지만 실행 속도는 느림
․BASIC, SNOBOL, LISP, APL 등이 인터프리터를 사용함


▪매크로 : 프로그램 작성시 한 프로그램 내에서 동일한 코드가 반복될 경우 반복되는 코드를 한번만 작성하여 특정 이름으로 정의한 후 그 코드가 필요할 때마다 정의된 이름을 호출하여 사용하는 것
▪매크로 프로세서 : 원시 프로그램에 존재하는 매크로 호출 부분에 매크로(Macro) 프로그램을 삽입하여 확장된 원시 프로그램을 생성하는 시스템 소프트웨어
▪매크로 프로세서 처리 과정 : 매크로 정의 인식 → 매크로 정의 저장 → 매크로 호출 인식 → 매크로 확장과 인수(매개 변수) 치환


정의	컴퓨터 내부로 정보를 들여오거나 로드 모듈을 디스크 등의 보조기억장치로부터 주기억장치에 적재하는 시스템 소프트웨어
기능	․할당(Allocation) : 실행 프로그램을 실행시키기 위해 기억장치 내에 옮겨놓을 공간을 확보하는 기능
․연결(Linking) : 부프로그램 호출시 그 부프로그램이 할당된 기억 장소의 시작 주소를 호출한 부분에 등록하여 연결하는 기능
․재배치(Relocation) : 디스크 등의 보조기억장치에 저장된 프로그램이 사용하는 각 주소들을 할당된 기억 장소의 실제 주소로 배치시키는 기능
․적재(Loading) : 실행 프로그램을 할당된 기억공간에 실제로 옮기는 기능
종류	․Compile And Go 로더 : 별도의 로더없이 언어 번역 프로그램이 로더의 기능까지 수행하는 방식(할당, 재배치, 적재 작업을 모두 언어 번역 프로그램이 담당)
․절대 로더(Absolute Loader) : 목적 프로그램을 기억 장소에 적재시키는 기능만 수행하는 로더(할당 및 연결은 프로그래머가, 재배치는 언어 번역 프로그램이 담당)
․직접 연결 로더(Direct Linking Loader) : 일반적인 기능의 로더로, 로더의 기본 기능 4가지를 모두 수행하는 로더
․동적 적재 로더(Dynamic Loding Loader) : 프로그램을 한꺼번에 적재하는 것이 아니라 실행시 필요한 일부분만을 적재하는 로더


▪언어 번역 프로그램이 생성한 목적 프로그램들과 라이브러리, 또 다른 실행 프로그램(로드 모듈) 등을 연결하여 실행 가능한 로드 모듈을 만드는 시스템 소프트웨어
▪연결 기능만 수행하는 로더의 한 형태로, 링커에 의해 수행되는 작업을 링킹(Linking)이라 함


▪실행중인 프로그램, PCB를 가진 프로그램, 실기억장치에 저장된 프로그램
▪프로세서가 할당되는 실체, 프로시저가 활동 중인 것, 
▪비동기적 행위를 일으키는 주체, 지정된 결과를 얻기 위한 일련의 계통적 동작
▪목적 또는 결과에 따라 발생되는 사건들의 과정



▪PCB : 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳
▪PCB에 저장되어 있는 정보 : 프로세스의 현재 상태, 포인터, 프로세스 고유 식별자, 스케줄링 및 프로세서의 우선 순위, CPU 레지스터 정보, 주기억장치 관리 정보, 입․출력 상태 정보, 계정 정보


▪프로세스의 주요 상태
준비(Read)	프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태
실행(Run)	․준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
․프로세스 수행이 완료되기 전에 프로세스에게 주어진 프로세서 할당 시간이 종료(Time Run Out)되면 프로세스는 준비 상태로 전이됨
․실행중인 프로세스에 입․출력(I/O) 처리가 필요하면 실행중인 프로세스는 대기 상태로 전이됨
대기(Wait), 보류, 블록(Block)	프로세스에 입․출력 처리가 필요하면 현재 실행중인 프로세스가 중단되고, 입․출력 처리가 완료될 때까지 대기하고 있는 상태
▪프로세스 상태 전이 관련 용어
Dispatch 	준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당 받아 실행 상태로 전이되는 과정
Wake - Up 	입․출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정


▪정의 : 프로세스가 생성되어 실행될때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업
▪목적 : 공정성, 처리율 증가, CPU 이용률 증가, 우선 순위 제도, 오버헤드 최소화, 응답 시간 최소화, 반환 시간 최소화, 대기 시간 최소화, 균형 있는 자원의 사용, 무한 연기 회피


비선점(Non-preemptive) 스케줄링	․이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
․프로세스가 CPU를 할당 받으면 해당 프로세스가 완료될 때까지 CPU를 사용함
․모든 프로세스에 대한 요구를 공정하게 처리할 수 있음
․프로세스 응답 시간의 예측이 용이하며, 일괄 처리 방식에 적합함
․중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우가 발생할 수 있음
․종류 : FCFS, SJF, 우선 순위, HRN, 기한부 등의 알고리즘 
선점(Preemptive) 스케줄링
	․하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
․우선 순위가 높은 프로세스를 빠르게 처리할 수 있음
․주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용됨
․종류 : SRT, 선점 우선 순위, Round Robin, 다단계 큐, 다단계 피드백 큐 등의 알고리즘 


FCFS 
(First-Come First-Service)	․준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법
․먼저 도착한 것이 먼저 처리되어 공평성은 유지되지만 짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을 기다리게 됨
SJF
(Shortest Job First)	․실행 시간이 가장 짧은 프로세스에 먼저 CPU를 할당하는 기법
․가장 적은 평균 대기 시간을 제공하는 최적 알고리즘
HRN(HightestResponse-ratio Next)	․실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로, 대기 시간과 서비스(실행) 시간을 이용하는 기법
                        대기 시간 + 서비스 (실행) 시간
                              서비스 (실행) 시간
기한부
(Deadline)	․프로세스에게 일정한 시간을 주어 그 시간 안에 프로세스를 완료하도록 하는 기법
․시스템은 프로세스에게 할당할 정확한 시간을 추정해야 하며, 이를 위해서 사용자는 시스템이 요구한 프로세스에 대한 정확한 정보를 제공해야 함
우선순위
(Priority)	준비상태 큐에서 기다리는 각 프로세스마다 우선 순위를 부여하여 그 중 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법


▪시스템에서 특정 프로세스의 우선 순위가 낮아 무한정 기다리게 되는 경우, 한번 양보하거나 기다린 시간에 비례하여 일정 시간이 지나면 우선 순위를 한 단계씩 높여 가까운 시간 안에 자원을 할당받도록 하는 기법
▪SJF나 우선 순위 기법에서 발생할 수 있는 무한 연기 상태, 기아 상태를 예방할 수 있음


선점 우선 순위	준비상태 큐의 프로세스들 중에서 우선 순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법
SRT(Shortest Remaining Time)	비선점 기법인 SJF 알고리즘을 선점 형태로 변경한 기법으로, 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행 시간을 비교하여 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU를 할당하는 기법
RR
(Round Robin)	․시분할 시스템(Time Sharing System)을 위해 고안된 방식으로, FCFS 알고리즘을 선점 형태로 변형한 기법
․FCFS 기법과 같이 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받지만 각 프로세스는 할당된 시간(Time Slice, Quantum) 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치됨
․할당되는 시간이 클 경우 FCFS 기법과 같아지고, 할당되는 시간이 작을 경우 문맥교환 및 오버헤드가 자주 발생됨
다단계 큐 (Multi level Queue)	프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비상태 큐를 사용하는 기법
다단계 피드백 큐(Multi level 
Feedback 
Queue)	특정 그룹의 준비상태 큐에 들어간 프로세스가 다른 준비상태 큐로 이동할 수 없는 다단계 큐 기법을 준비상태 큐 사이를 이동할 수 있도록 개선한 기법


▪다중 프로그래밍 운영체제에서 여러 개의 프로세스가 공유하는 데이터 및 자원에 대하여 어느 한 시점에서는 하나의 프로세스만 자원 또는 데이터를 사용하도록 지정된 공유 자원(영역)
▪임계 구역에는 하나의 프로세스만 접근할 수 있으며, 해당 프로세스가 자원을 반납한 후에만 다른 프로세스가 자원이나 데이터를 사용할 수 있음


▪특정 프로세스가 공유 자원을 사용하고 있을 경우 다른 프로세스가 해당 공유 자원을 사용하지 못하게 제어하는 기법
▪여러 프로세스가 동시에 공유 자원을 사용하려 할 때 각 프로세스가 번갈아 가며 공유 자원을 사용하도록 하는 것으로 임계 구역을 유지하는 기법


▪각 프로세스에 제어 신호를 전달하여 순서대로 작업을 수행하도록 하는 기법
▪E.J.Dijkstra가 제안하였으며, P와 V라는 2개의 연산에 의해서 동기화를 유지시키고, 상호 배제의 원리를 보장함
▪S는 P와 V 연산으로만 접근 가능한 세마포어 변수로, 공유 자원의 개수를 나타내며 0과 1 혹은 0과 양의 값을 가질 수 있음
▪P 연산 : 자원을 사용하려는 프로세스들의 진입 여부를 자원의 개수(S)를 통해 결정하는 것으로, wait 동작이라 함
▪V 연산 : 대기 중인 프로세스를 깨우는 신호(Wake Up)로서, signal 동작이라 함


▪동기화를 구현하기 위한 특수 프로그램 기법으로 특정 공유 자원을 프로세스에게 할당하는데 필요한 데이터와 이 데이터를 처리하는 프로시저로 구성됨
▪자료 추상화와 정보 은폐 개념을 기초로 하며 공유 자원을 할당하기 위한 병행성 구조로 이루어져 있음
▪모니터 내의 공유 자원을 사용하려면 프로세스는 반드시 모니터의 진입부를 호출해야 함
▪외부의 프로시저는 직접 액세스할 수 없으며, 모니터의 경계에서 상호 배제가 시행됨
▪한순간에 하나의 프로세스만 진입하여 자원을 사용할 수 있음


정의	상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상
필요 
충분 
조건	․상호배제(Mutual Exclusion) : 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함
․점유와 대기 (Hold & Wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함
․비선점(Non-preemptive) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 함
․환형대기(Circular Wait) : 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함


▪예방 기법(Prevention) : 교착 상태가 발생되지 않도록 사전에 시스템을 제어하는 방법으로, 교착 상태 발생의 4가지 조건 중에서 상호 배제를 제외한 어느 하나를 제거(부정)함으로써 수행됨
점유 및 대기 부정	프로세스가 실행되기 전 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나 자원이 점유되지 않은 상태에서만 자원을 요구하도록 함
비선점 부정	자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 함
환형대기 부정	자원을 선형 순서로 분류하여 고유 번호를 할당하고, 각 프로세스는 현재 점유한 자원의 고유 번호보다 앞이나 뒤 어느 한쪽 방향으로만 자원을 요구하도록 하는 것
▪회피 기법(Avoidance) : 교착 상태가 발생할 가능성을 배제하지 않고, 교착 상태가 발생하면 적절히 피해나가는 방법으로, 주로 은행원 알고리즘(Banker's Algorithm)이 사용됨
은행원 알고리즘	․Dijkstra가 제안한 것으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래한 기법
․각 프로세스에게 자원을 할당하여 교착 상태가 발생하지 않으며 모든 프로세스가 완료될 수 있는 상태를 안전 상태, 교착 상태가 발생할 수 있는 상태를 불안전 상태라고 함
▪발견 기법(Detection) : 시스템에 교착 상태가 발생했는지 점검하여 교착 상태에 있는 프로세스와 자원을 발견하는 것
▪회복 기법(Recovery) : 교착 상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것


▪반입(Fetch) 전략 : 보조기억장치에 보관 중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략
요구 반입	실행 중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법
예상 반입	실행 중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법
▪배치(Placement) 전략 : 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략
최초 적합
(First Fit)	프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법
최적 적합
(Best Fit)	프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법
최악 적합
(Worst Fit)	프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법
▪교체(Replacement) 전략 : 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략으로, FIFO, OPT, LRU, LFU, NUR, SCR 등이 있음


▪주기억장치를 운영체제 영역과 사용자 영역으로 나누어 한 순간에는 오직 한 명의 사용자만이 주기억장치의 사용자 영역을 사용하는 기법
▪오버레이(Overlay) 기법 : 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법으로, 보조기억장치에 저장된 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 차례로 주기억장치에 적재하여 프로그램을 실행함
▪스와핑(Swapping) 기법 : 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법


▪고정 분할 할당 : 프로그램을 할당하기 전에 운영체제가 주기억장치의 사용자 영역을 여러 개의 고정된 크기로 분할하고, 준비상태 큐에서 준비 중인 프로그램을 각 영역에 할당하여 수행하는 기법
▪가변 분할 할당 : 고정 분할 할당 기법의 단편화를 줄이기 위한 것으로, 미리 주기억장치를 분할해 놓는 것이 아니라 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분할하는 기법


▪분할된 주기억장치에 프로그램를 할당하고 반납하는 과정을 반복하면서 사용되지 않고 남는 기억장치의 빈 공간 조각
▪내부(Internal ) 단편화 : 분할된 영역이 할당될 프로그램의 크기보다 크기 때문에 프로그램이 할당된 후 사용되지 않고 남아 있는 빈 공간
▪외부(External ) 단편화 : 분할된 영역이 할당될 프로그램의 크기보다 작기 때문에 프로그램이 할당될 수 없어 사용되지 않고 빈 공간으로 남아 있는 분할된 전체 영역 


▪통합(Coalescing) 기법 : 주기억장치 내에 인접해 있는 단편화된 공간을 하나의 공간으로 통합하는 작업
▪압축(Compaction) 기법, 집약 : 주기억장치 내에 분산되어 있는 단편화된 빈 공간을 결합하여 하나의 큰 가용 공간을 만드는 작업으로, 여러 위치에 분산된 단편화된 빈 공간을 주기억장치의 한쪽 끝으로 옮겨서 큰 기억 공간을 만듬


페이징
(Paging) 기법	․가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법
․외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있음
세그먼테이션
(Segmentation) 기법	․가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법
․프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖고 있음
․다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치 보호키(Storage Protection Key)가 필요함


OPT 
(Optimal 
Replacement, 최적 교체)	․앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
․각 페이지의 호출 순서와 참조 상황을 미리 예측해야 하므로 실현 가능성이 희박함
FIFO(First In First Out)	․각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법
․이해하기 쉽고, 프로그래밍 및 설계가 간단하며, 벨레이디의 모순(Belady's Anomaly) 현상이 발생함
LRU(Least 
Recently Used)	․최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
․각 페이지마다 계수기나 스택을 두어 현 시점에서 가장 오랫동안 사용하지 않은 즉, 가장 오래 전에 사용된 페이지를 교체함
LFU(Least Frequently Used)	․사용 빈도가 가장 적은 페이지를 교체하는 기법
․프로그램 실행 초기에 많이 사용된 페이지가 그 후로 사용되지 않을 경우에도 프레임을 계속 차지할 수 있음
NUR
(Not Used
Recently)	․최근에 사용하지 않은 페이지를 교체하는 기법
․최근의 사용 여부를 확인하기 위해서 각 페이지마다 참조 비트(Reference Bit)와 변형 비트(Modified Dit, Dirty Bit)가 사용됨
SCR(Second Chance Replacement)	가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법 


페이지가 작을 경우	․페이지의 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어듬
․프로세스(프로그램) 수행에 필요한 내용만 주기억장치에 적재할 수 있고, Locality(국부성)에 더 일치할 수 있기 때문에 기억장치 효율이 높아짐
․페이지 정보를 갖는 페이지 맵 테이블의 크기가 커지고, 맵핑 속도가 늦어짐
․디스크 접근 횟수가 많아져서 전체적인 입․출력 시간은 늘어남
페이지가 클 경우	․페이지 정보를 갖는 페이지 맵 테이블의 크기가 작아지고, 맵핑 속도가 빨라짐
․디스크 접근 횟수가 줄어들어 전체적인 입․출력의 효율성이 증가됨
․페이지의 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어남
․프로그램 수행에 불필요한 내용까지도 주기억장치에 적재될 수 있음


▪프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론
▪스래싱을 방지하기 위한 워킹 셋 이론의 기반이 됨
▪프로세스가 집중적으로 사용하는 페이지를 알아내는 방법 중 하나로, 가상 기억장치 관리의 이론적인 근거가 됨
▪Locality 종류
시간 구역성(Temporal Locality)	․프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상
․시간 구역성이 이루어지는 기억 장소 : Loop(반복, 순환), 스택(Stack), 부프로그램(Sub Routine), Counting(1씩 증감), Totaling(집계)에 사용되는 변수(기억 장소)
공간 구역성
(Spatial Loca lity)	․프로세스 실행시 일정 위치의 페이지를 집중적으로 액세스하는 현상
․공간 구역성이 이루어지는 기억 장소 : 배열 순회(Array Tra versal), 순차적 코드의 실행, 프로그래머들이 관련된 변수(데이터를 저장할 기억장소)들을 서로 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수를 참조할 때 사용


▪워킹 셋(Working Set) : 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합으로, 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상을 줄임
▪페이지 부재 빈도(PFF, Page Fault Frequency) : 페이지 부재가 일어나는 횟수
▪페이지 부재 빈도 방식 : 페이지 부재율(Page Fault Rate)에 따라 주기억장치에 있는 페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식


▪프로세스의 처리 시간보다 페이지 교체 시간이 더 많아지는 현상
▪다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정 중 자주 페이지 부재가 발생함으로 인해 나타나는 현상으로 전체 시스템의 성능이 저하됨
▪다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용율은 어느 특정 시점까지는 높아지지만 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용율은 급격히 감소됨
▪CPU 이용율을 높이고, 스래싱 현상을 방지하려면 다중 프로그래밍의 정도를 적정 수준으로 유지하고, 페이지 부재 빈도(Page Fault Frequency)를 조절하여 사용하며, Working Set을 유지해야 함


FCFS
(First-Come
First-Service) 	․가장 간단한 스케줄링으로, 디스크 대기 큐에 가장 먼저 들어온 트랙에 대한 요청을 먼저 서비스하는 기법
․디스크 대기 큐에 들어온 순서대로 서비스하기 때문에 더 높은 우선 순위의 요청이 입력되어도 순서가 바뀌지 않아 공평성이 보장됨
SSTF
(Shortest-Seek-Time-First)	․탐색 거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스하는 기법
․현재 헤드 위치에서 가장 가까운 거리에 있는 트랙으로 헤드를 이동시킴
․FCFS보다 처리량이 많고, 평균 탐색 시간이 짧음
․처리량이 많은 일괄 처리 시스템에 유용함
SCAN	․SSTF가 갖는 탐색 시간의 편차를 해소하기 위한 기법
․현재 헤드의 위치에서 진행 방향이 결정되면 탐색 거리가 짧은 순서에 따라 그 방향의 모든 요청을 서비스하고, 끝까지 이동한 후 역방향의 요청 사항을 서비스함
C-SCAN(Circular SCAN)	․항상 바깥쪽에서 안쪽으로 움직이면서 가장 짧은 탐색 거리를 갖는 요청을 서비스하는 기법
․헤드는 트랙의 바깥쪽에서 안쪽으로 한 방향으로만 움직이며 서비스하여 끝까지 이동한 후, 안쪽에 더 이상의 요청이 없으면 헤드는 가장 바깥쪽의 끝으로 이동한 후 다시 안쪽으로 이동하면서 요청을 서비스함
N-step SCAN	SCAN 기법을 기초로 하며, 어떤 방향의 진행이 시작될 당시에 대기 중이던 요청들만 서비스하고, 진행 도중 도착한 요청들은 한데 모아서 다음의 반대 방향 진행 때 서비스하는 기법


▪사용자와 보조기억장치 사이에서 인터페이스 제공
▪사용자가 파일을 생성, 수정, 제거할 수 있도록 함
▪적절한 제어 방식을 통해 타인의 파일을 공동으로 사용할 수 있도록 함
▪사용자가 적합한 구조로 파일을 구성할 수 있도록 함
▪불의의 사태를 대비하여 파일의 예비와 복구 등의 기능을 제공함


▪파일을 관리하기 위한 시스템(운영체제)이 필요로하는 파일에 대한 정보를 갖고 있는 제어 블록(파일 제어 블록, FCB)
▪보통 파일 디스크립터는 보조기억장치 내에 저장되어 있다가, 해당 파일이 Open될때 주기억장치로 옮겨짐
▪파일 시스템이 관리하므로 사용자가 직접 참조할 수 없음
▪파일 디스크립터의 정보 : 파일 이름, 보조기억장치에서의 파일 위치, 파일 구조, 보조기억장치의 유형, 액세스 제어 정보, 파일 유형, 생성 날짜와 시간, 제거 날짜와 시간, 최종 수정 날짜 및 시간, 액세스한 횟수


▪레코드를 논리적인 처리 순서에 따라 연속된 물리적 저장 공간에 기록하는 것
▪주로 순차 접근이 가능한 자기 테이프에서 사용
▪장점 : 파일의 구성 용이, 기억 공간의 이용 효율 높음, 접근 속도 빠름
▪단점 : 파일에 새로운 레코드를 삽입하거나 삭제하는 경우 시간이 많이 걸림, 검색 효율이 낮음


▪파일을 구성하는 레코드를 임의의 물리적 저장 공간에 기록하는 것
▪레코드에 특정 기준으로 키가 할당되며, 해싱 함수(Hashing Function)를 이용하여 이 키에 대한 보조기억장치의 물리적 상대 레코드 주소를 계산한 후 해당하는 주소에 레코드를 저장함
▪레코드는 해싱 함수에 의해 계산된 물리적 주소를 통해 접근 가능
▪임의 접근이 가능한 자기 디스크나 자기 드럼 사용
▪장점 : 파일의 각 레코드에 직접 접근하거나 기록할 수 있음, 접근 시간이 빠르고, 레코드의 삽입, 삭제, 갱신이 용이함
▪단점 : 레코드의 주소 변환 과정이 필요하며, 이 과정으로 인해 시간이 소요됨, 기억 공간의 효율이 저하됨


▪순차 파일과 직접 파일에서 지원하는 편성 방법이 결합된 형태
▪각 레코드를 키값 순으로 논리적으로 저장하고, 시스템은 각 레코드의 실제 주소가 저장된 색인을 관리함
▪레코드를 참조하려면 색인을 탐색한 후 색인이 가리키는 포인터(주소)를 사용하여 직접 참조할 수 있음
▪기본 영역, 색인 영역, 오버 플로우 영역으로 구성되며, 색인 영역은 트랙 색인 영역, 실린더 색인 영역, 마스터 색인 영역으로 분류됨
▪장점 : 순차 처리와 임의 처리가 모두 가능, 효율적인 검색 가능, 삭제, 삽입, 갱신이 용이함
▪단점 : 기억 공간이 필요함, 접근 시간이 직접 파일보다 느림


1단계 디렉토리	․가장 간단하고, 모든 파일이 하나의 디렉토리 내에 위치하여 관리되는 구조
․모든 파일들이 유일한 이름을 가지고 있어야 함
․모든 파일이 같은 디렉토리내에 유지되므로 이해가 용이하지만, 파일의 수나 사용자의 수가 증가하면 파일 관리가 복잡해짐
2단계 디렉토리	․중앙에 마스터 파일 디렉토리가 있고, 그 아래에 사용자별로 서로 다른 파일 디렉토리가 있는 2 계층 구조
․마스터 파일 디렉토리는 사용자 파일 디렉토리를 관리하고, 사용자 파일 디렉토리는 사용자별 파일을 관리함
․서로 다른 디렉토리에서는 동일한 파일 이름을 사용할 수 있음
트리 
디렉토리	․하나의 루트 디렉토리와 여러 개의 종속(서브) 디렉토리로 구성된 구조
․DOS, Windows, UNIX 등의 운영체제에서 사용되는 디렉토리 구조
․동일한 이름의 파일이나 디렉토리를 생성할 수 있음
․디렉토리의 생성과 파괴가 비교적 용이함
비순환 그래프 디렉토리	․하위 파일이나 하위 디렉토리를 공동으로 사용할 수 있는 것으로, 사이클이 허용되지 않는 구조
․디스크 공간을 절약할 수 있음
․하나의 파일이나 디렉토리가 여러 개의 경로 이름을 가질 수 있음
․공유된 파일을 삭제할 경우 고아 포인터(Dangling Pointer)가 발생할 수 있음
일반적인 그래프 디렉토리	․트리 구조에 링크(Link)를 첨가시켜 순환을 허용하는 그래프 구조
․디렉토리와 파일 공유에 완전한 융통성이 있음
․불필요한 파일을 제거하여 사용 공간을 늘리기 위하여 참조 계수기가 필요함


▪연속 할당 : 파일을 디스크의 연속된 기억 공간에 할당하는 방법으로, 생성되는 파일 크기만큼의 공간을 있어야 함
▪불연속 할당 : 파일의 크기가 변경될 경우 구현이 어려운 연속 할당의 단점을 보완하기 위한 것으로, 디스크 공간을 일정 단위로 나누어 할당하는 기법
섹터 단위 할당	하나의 파일이 디스크의 섹터 단위로 분산되어 할당되는 방법으로, 하나의 파일에 속하는 섹터들이 연결 리스트(Linked List)로 구성되어 있음
블록 단위 할당	․하나의 파일이 연속된 여러 개의 섹터를 묶은 블록 단위로 할당되는 방법
․블록 단위 할당에는 블록 체인 할당, 색인 블록 체인 할당, 블록 지향 파일 사상 기법이 있음


▪접근 제어 행렬(Access Control Matrix) : 자원 보호의 일반적인 모델로, 객체에 대한 접근 권한을 행렬로써 표시한 기법
▪전역 테이블(Global Table) : 가장 단순한 구현 방법으로, 3개의 순서쌍인 영역, 객체, 접근 권한의 집합을 목록 형태로 구성한 기법
▪접근 제어 리스트(Access Control List) : 접근 제어 행렬에 있는 각 열, 즉 객체를 중심으로 접근 리스트를 구성한 기법
▪권한(자격) 리스트(Capability List) : 접근 제어 행렬에 있는 각 행, 즉 영역을 중심으로 권한 리스트를 구성한 기법


▪파일의 명명(Naming) : 접근하고자 하는 파일 이름을 모르는 사용자를 접근 대상에서 제외시키는 기법
▪비밀번호(Password, 암호) : 각 파일에 판독 암호와 기록 암호를 부여하여 암호를 아는 사용자에게만 접근을 허용하는 기법
▪접근 제어(Access Control) : 사용자에 따라 공유 데이터에 접근할 수 있는 권한을 제한하는 방법


외부 보안	․시설 보안 : 천재 지변이나 외부 침입자로부터의 보안
․운용 보안 : 전산소 관리 및 경영자들의 정책과 통제에 의해 이루어지는 보안
사용자 인터페이스 
보안	운영체제가 사용자의 신원을 확인한 후 권한이 있는 사용자에게만 시스템의 프로그램과 데이터를 사용할 수 있게 하는 보안 기법
내부 보안	하드웨어나 운영체제의 내장된 보안 기능을 이용하여 시스템의 신뢰성을 유지하고, 보안 문제를 해결하는 기법


▪데이터를 보낼 때 송신자가 지정한 수신자 이외에는 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것
▪비밀키 시스템(Private Key System, 개인키 시스템) : 동일한 키로 데이터를 암호화하고, 해독(복호화)하는 대칭 암호화 기법으로, 대표적인 암호화 방식에는 DES가 있음
▪공용키 시스템(Public Key System, 공개키 시스템) : 서로 다른 키로 데이터를 암호화하고, 해독하는 비대칭 암호화 기법으로, 대표적인 암호화 방식에는 RSA가 있음


시분할 및 공유 버스	․프로세서, 주변장치, 기억장치 등의 각종 장치들간을 ‘버스’라는 단일 경로로 연결한 방식
․버스에 이상이 발생하면 전체 시스템이 가동되지 않음
․장치 연결이 단순하고, 경제적이며, 융통성이 있음
․장치 추가가 용이하지만 버스에 이상이 발생하면 전체 시스템이 가동되지 않음
크로스바 교환 행렬	․시분할 및 공유 버스 구조에서 버스의 수를 기억장치 수만큼 증가시켜 연결한 방식
․각 기억장치마다 다른 경로를 사용할 수 있음
하이퍼 큐브	․다수의 프로세서들을 연결하는 방식으로 비교적 경제적인 방식
․다수의 프로세서를 연결할 수 있으며, 확장성이 좋음
․하나의 프로세서에 연결되는 다른 프로세서의 수(연결점)가 n개 일 경우 프로세서는 총 2n개가 필요함
다중 포트 기억장치	․시분할 및 공유 버스 방식과 크로스바 교환 행렬을 혼합한 형태의 방식
․많은 수의 프로세서를 쉽게 연결할 수 있음
․다양한 연결이 가능하며, 전송 시간이 비교적 느림


주/종 처리기	․하나의 프로세서를 Master(주프로세서)로 지정하고, 나머지들은 Slave(종프로세서)로 지정하는 구조
․주프로세서가 고장나면 전체 시스템이 다운됨
․주프로세서 : 입․출력과 연산 담당, 운영체제 수행
․종프로세서 : 연산만 담당
분리 실행처리기	․주/종 처리기의 비대칭성을 보완하여 각 프로세서가 독자적인 운영체제를 가지고 있도록 구성한 구조
․각 프로세서에서 발생하는 인터럽트는 해당 프로세서에서 해결
․각 프로세서가 독자적인 운영체제를 가지고 있기 때문에 한 프로세서가 고장나더라도 전체 시스템이 다운되지 않음

대칭적 처리기	․여러 프로세서들이 완전한 기능을 갖춘 하나의 운영체제를 공유하여 수행하는 구조
․가장 복잡한 구조를 가지고 있으나 가장 강력한 시스템임
․여러 개의 프로세서가 동시에 수행될 수 있고, 시스템의 전반적인 정보를 통일적이고 일관성 있게 운영함


약결합
(Loosely Coupled) 시스템	․각 프로세서마다 독립된 메모리를 가진 시스템으로, 분산처리 시스템이라고도 함
․둘 이상의 독립된 컴퓨터 시스템을 통신망(통신 링크)을 통하여 연결한 시스템
․각 시스템마다 독자적인 운영체제를 가지고 있음
․각 시스템은 독립적으로 작동할 수도 있고, 필요한 경우에는 상호 통신할 수도 있음
․프로세서 간의 통신은 메시지 전달이나 원격 프로시저 호출을 통해서 이루어짐
․각 시스템마다 독자적인 운영이 가능하므로 CPU 간의 결합력이 약함
강결합
(Tightly Coupled) 시스템	․동일 운영체제 하에서 여러 개의 프로세서가 하나의 메모리를 공유하여 사용하는 시스템으로, 다중(병렬) 처리 시스템이라고도 함
․하나의 운영체제가 모든 프로세서와 시스템 하드웨어를 제어함
․프로세서 간의 통신은 공유 메모리를 통해서 이루어짐
․하나의 메모리를 사용하므로 CPU 간의 결합력이 강함


▪목적 : 자원 공유, 연산 속도 향상, 신뢰도 향상, 컴퓨터 통신
▪장점 : 통신 용이, 장치 공유, 데이터 공유, 중앙 컴퓨터 과부하 줄임, 컴퓨터의 위치를 몰라도 자원 사용 가능, 시스템의 점진적 확장 가능 등
▪단점 : 중앙 집중형 시스템에 비해 소프트웨어 개발이 어려움, 보안 문제 발생, 설계 복잡 등


▪투명성(Transparency) : 사용자가 분산된 시스템에 위치한 여러 자원을 사용할 때 각 자원의 위치 정보를 알지 못하고 마치 하나의 커다란 시스템을 사용하는 것처럼 인식하도록 하는 것
▪여러 유형의 투명성을 통해 자원의 위치나 정보가 변경되더라도 사용자가 이를 인식하지 못하게 됨
▪투명성의 종류 : 위치 투명성, 이주 투명성, 복제 투명성, 병행 투명성, 접근 투명성, 성능 투명성, 규모 투명성, 고장 투명성


완전 연결
(Fully 
Connection)형	․각 사이트들이 시스템 내의 다른 모든 사이트들과 직접 연결된 구조
․사이트의 수가 n개이면 링크(연결) 수는 n(n-1)/2 개임
․기본 비용은 많이 들지만 통신 비용은 적게 들고, 신뢰성이 높음
부분 연결
(Partially 
Connection)형	․시스템 내의 일부 사이트들 간에만 직접 연결된 형태로, 직접 연결되지 않은 사이트는 연결된 다른 사이트를 통해 통신하는 구조
․기본 비용은 완전 연결형보다 적게 들고, 통신 비용은 완전 연결형보다 많이 듬
․완전 연결형보다 신뢰성이 낮음
트리(Tree)/계층(Hierarchy)형	․분산 처리 시스템의 가장 대표적인 형태로, 각 사이트들이 트리 형태로 연결된 구조
․기본 비용은 부분 연결형보다 적게 들고, 통신 비용은 트리의 깊이에 비례함
․부모(상위) 사이트의 자식(하위) 사이트들은 그 부모 사이트를 통해 통신이 이루어짐
․부모 사이트가 고장나면 그 자식 사이트들은 통신이 불가능함
스타(Star) 형/성형	․모든 사이트가 하나의 중앙 사이트에 직접 연결되어 있고, 그 외의 다른 사이트와는 연결되어 있지 않은 구조
․기본 비용은 사이트의 수에 비례하며, 통신 비용은 적게듬
․중앙 사이트를 제외한 사이트의 고장이 다른 사이트에 영향을 미치지 않지만, 중앙 사이트가 고장 날 경우 모든 통신이 단절됨
링(Ring)형/환형	․시스템 내의 각 사이트가 인접하는 다른 두 사이트와만 직접 연결된 구조
․정보는 단방향 또는 양방향으로 전달될 수 있음
․기본 비용은 사이트 수에 비례하고, 목적 사이트에 데이터를 전달하기 위해 링을 순환할 경우 통신 비용이 증가함
다중 접근 버스 연결(Multi Access Bus Connection)형	․시스템 내의 모든 사이트들이 공유 버스에 연결된 구조
․기본 비용은 사이트 수에 비례하고, 통신 비용은 일반적으로 저렴함
․사이트의 고장은 다른 사이트의 통신에 영향을 주지 않지만, 버스의 고장은 전체 시스템에 영향을 줌


▪시분할 시스템을 위해 설계된 대화식 운영체제로, 소스가 공개된 개방형 시스템(Open System)
▪대부분 C언어로 작성되어 있어 이식성이 높으며 장치, 프로세스간의 호환성이 높음
▪크기가 작고 이해하기가 쉬우며, Multi-User, Multi-Tasking 지원
▪많은 네트워킹 기능을 제공하므로 통신망(Network) 관리용 운영체제로 적합함
▪트리 구조의 파일 시스템으로, 전문적인 프로그램 개발에 용이함
▪다양한 유틸리티 프로그램들이 존재함


커널(Kernel)	․UNIX의 가장 핵심적인 부분
․하드웨어를 보호하고, 프로그램들과 하드웨어 간의 인터페이스 역할 담당
․프로세스 관리, 기억장치 관리, 파일 관리, 입․출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러 가지 기능 수행
쉘(Shell)	․사용자의 명령어를 인식하여 프로그램을 호출하고, 명령을 수행하는 명령어 해석기
․시스템과 사용자 간의 인터페이스 담당
․DOS의 COMMAND.COM과 같은 기능 수행
․주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조기억장치에서 교체 처리 가능
유틸리티(Utility)	․일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용
․DOS에서의 외부 명령어에 해당됨


▪부트 블록 : 부팅시 필요한 코드를 저장하고 있는 블록
▪슈퍼 블록 : 전체 파일 시스템에 대한 정보를 저장하고 있는 블록
▪Inode 블록 : 각 파일이나 디렉토리에 대한 모든 정보를 저장하고 있는 블록으로, 파일 소유자의 사용자 번호(UID) 및 그룹 번호(GID), 파일 크기, 파일 type, 생성 시기, 최종 변경 시기, 최근 사용 시기, 파일의 보호 권한, 파일 링크 수, 데이터가 저장된 블록의 시작 주소 등의 정보를 가지고 있음
▪데이터 블록 : 디렉토리별로 디렉토리 엔트리와 실제 파일에 대한 데이터가 저장된 블록


명령어	의미
fork	새로운 프로세스 생성
exec	새로운 프로세스 수행
&	백그라운드 처리를 위해 명령의 끝에 입력
mv	파일 이동, 이름 변경
rm	파일 삭제
chmod	파일의 사용 허가 지정
mount	파일 시스템을 마운팅 함
mkfs	파일 시스템 생성
chdir	현재 사용할 디렉토리 위치 변경
fsck	파일 시스템 검사․보수
rmdir	디렉토리 삭제
ls	현재 디렉토리 내의 파일 목록 확인


▪GUI(Graphic User Interface, 그래픽 사용자 인터페이스) : 키보드로 명령어를 직접 입력하지 않고, 아이콘이나 메뉴를 마우스로 선택하여 모든 작업을 수행하는 방식
▪선점형 멀티태스킹(Preemptive Multi-Tasking) : 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식
▪FAT 32 파일 시스템 사용 
▪PnP(Plug and Play : 자동 감지 기능) 사용 : 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 운영체제가 자동으로 구성해 주는 기능
▪OLE(Object Linking and embedding) 사용 : 다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체(Object)를 현재 작성 중인 문서에 자유롭게 연결(Linking)하거나 삽입(Embedding)하여 편집할 수 있게 하는 기능
▪255자의 긴 파일명 사용 : 파일 이름을 VFAT(Virtual File Allocati on Table)를 이용하여 최대 255자까지 지정할 수 있음


▪CUI(Character User Interface, 문자 중심의 사용자 인터페이스) : 작업을 위한 실행 명령을 문자(Character)로 직접 입력하여 실행시킴
▪Single-User : 하나의 컴퓨터를 한 사람만이 사용
▪Single-Tasking : 한 번에 하나의 프로그램만을 수행
▪MSDOS.SYS : 프로세스 관리, 메모리 관리, 주변장치 관리, 파일 관리 등의 파일 입․출력 시스템 호출 담당
▪IO.SYS : MSDOS.SYS의 입․출력 요구에 따라 실제 입․출력 처리 담당
▪COMMAND.COM : 명령을 해독하여 실행하는 파일
▪AUTOEXEC.BAT : 부팅시 먼저 수행될 일정하고 반복적인 명령들을 일괄적으로 모아놓은 파일
▪CONFIG.SYS : 컴퓨터 시스템의 환경 설정을 위한 파일


▪내부 명령어 : 실행 과정이 간단하고 기본적인 기능을 수행하는 것으로, 메모리에 항상 상주하는 명령어(DIR, COPY, TYPE, REN, DEL, MD, CD, RD 등)
▪외부 명령어 : 실행 과정이 복잡하거나 자주 사용하지 않는 것으로, 디스크에 파일로 저장되어 있는 명령어(UNDELETE, SYS, ATTRIB, MOVE, FIND, CHKDSK 등)
감시(Supervisor) 프로그램	각종 프로그램의 실행과 시스템 전체의 작동 상태를 감시․감독하는 프로그램
작업 제어(Job Control) 프로그램	어떤 업무를 처리하고 다른 업무로의 이행을 자동으로 수행하기 위한 준비 및 그 처리에 대한 완료를 담당하는 프로그램
자료 관리(Data Management) 프로그램	주기억장치와 보조기억장치 사이의 데이터 전송과 보조기억장치의 자료 갱신 및 유지 보수 기능을 수행하는 프로그램
언어 번역(Language Translate)  프로그램	원시 프로그램을 기계어 형태의 목적 프로그램으로 번역하는 프로그램(어셈블러, 컴파일러, 인터프리터)
서비스(Service) 프로그램	컴퓨터를 효율적으로 사용할 수 있는 사용 빈도가 높은 프로그램
문제(Problem) 프로그램	특정 업무 및 해결을 위해 사용자가 작성한 프로그램
정의	컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
목적	․사용자와 컴퓨터 간의 인터페이스 제공
․자원의 효율적인 운영 및 자원 스케줄링
․데이터 공유 및 주변 장치 관리
․처리 능력 및 신뢰도 향상, 사용 가능도 향상
․응답(반응) 시간 단축, 반환 시간 등의 단축
기능	․프로세서, 기억장치, 입․출력장치, 파일 및 정보 등의 자원 관리
․자원의 스케줄링 기능 제공
․사용자와 시스템 간의 편리한 인터페이스 제공
․시스템의 각종 하드웨어와 네트워크 관리․제어
․시스템의 오류 검사 및 복구, 데이터 관리, 데이터 및 자원 공유
․자원 보호 기능 제공
․가상 계산기 기능 제공
컴파일러	․고급 언어로 작성된 프로그램 전체를 목적 프로그램으로 번역한 후, 링킹 작업을 통해 컴퓨터에서 실행 가능한 실행 프로그램 생성
․번역 과정이 번거롭고, 번역 시간이 오래 걸리지만 실행 속도가 빠름
․FORTRAN, COBOL, PASCAL, C, C++, PL/1 등이 컴파일러를 사용함
인터프리터	․고급 언어로 작성된 프로그램을 한 줄 단위로 받아들여  번역하고, 번역과 동시에 프로그램을 한 줄 단위로 즉시 실행시키는 프로그램
․줄 단위로 번역․실행되기 때문에 시분할 시스템에 유용함
․프로그램이 직접 실행되므로 목적 프로그램이 생성되지 않음
․번역 속도는 빠르지만 실행 속도는 느림
․BASIC, SNOBOL, LISP, APL 등이 인터프리터를 사용함
정의	컴퓨터 내부로 정보를 들여오거나 로드 모듈을 디스크 등의 보조기억장치로부터 주기억장치에 적재하는 시스템 소프트웨어
기능	․할당(Allocation) : 실행 프로그램을 실행시키기 위해 기억장치 내에 옮겨놓을 공간을 확보하는 기능
․연결(Linking) : 부프로그램 호출시 그 부프로그램이 할당된 기억 장소의 시작 주소를 호출한 부분에 등록하여 연결하는 기능
․재배치(Relocation) : 디스크 등의 보조기억장치에 저장된 프로그램이 사용하는 각 주소들을 할당된 기억 장소의 실제 주소로 배치시키는 기능
․적재(Loading) : 실행 프로그램을 할당된 기억공간에 실제로 옮기는 기능
종류	․Compile And Go 로더 : 별도의 로더없이 언어 번역 프로그램이 로더의 기능까지 수행하는 방식(할당, 재배치, 적재 작업을 모두 언어 번역 프로그램이 담당)
․절대 로더(Absolute Loader) : 목적 프로그램을 기억 장소에 적재시키는 기능만 수행하는 로더(할당 및 연결은 프로그래머가, 재배치는 언어 번역 프로그램이 담당)
․직접 연결 로더(Direct Linking Loader) : 일반적인 기능의 로더로, 로더의 기본 기능 4가지를 모두 수행하는 로더
․동적 적재 로더(Dynamic Loding Loader) : 프로그램을 한꺼번에 적재하는 것이 아니라 실행시 필요한 일부분만을 적재하는 로더
준비(Read)	프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태
실행(Run)	․준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
․프로세스 수행이 완료되기 전에 프로세스에게 주어진 프로세서 할당 시간이 종료(Time Run Out)되면 프로세스는 준비 상태로 전이됨
․실행중인 프로세스에 입․출력(I/O) 처리가 필요하면 실행중인 프로세스는 대기 상태로 전이됨
대기(Wait), 보류, 블록(Block)	프로세스에 입․출력 처리가 필요하면 현재 실행중인 프로세스가 중단되고, 입․출력 처리가 완료될 때까지 대기하고 있는 상태
Dispatch 	준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당 받아 실행 상태로 전이되는 과정
Wake - Up 	입․출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정
비선점(Non-preemptive) 스케줄링	․이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
․프로세스가 CPU를 할당 받으면 해당 프로세스가 완료될 때까지 CPU를 사용함
․모든 프로세스에 대한 요구를 공정하게 처리할 수 있음
․프로세스 응답 시간의 예측이 용이하며, 일괄 처리 방식에 적합함
․중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우가 발생할 수 있음
․종류 : FCFS, SJF, 우선 순위, HRN, 기한부 등의 알고리즘 
선점(Preemptive) 스케줄링
	․하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
․우선 순위가 높은 프로세스를 빠르게 처리할 수 있음
․주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용됨
․종류 : SRT, 선점 우선 순위, Round Robin, 다단계 큐, 다단계 피드백 큐 등의 알고리즘 
FCFS 
(First-Come First-Service)	․준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법
․먼저 도착한 것이 먼저 처리되어 공평성은 유지되지만 짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을 기다리게 됨
SJF
(Shortest Job First)	․실행 시간이 가장 짧은 프로세스에 먼저 CPU를 할당하는 기법
․가장 적은 평균 대기 시간을 제공하는 최적 알고리즘
HRN(HightestResponse-ratio Next)	․실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로, 대기 시간과 서비스(실행) 시간을 이용하는 기법
                        대기 시간 + 서비스 (실행) 시간
                              서비스 (실행) 시간
기한부
(Deadline)	․프로세스에게 일정한 시간을 주어 그 시간 안에 프로세스를 완료하도록 하는 기법
․시스템은 프로세스에게 할당할 정확한 시간을 추정해야 하며, 이를 위해서 사용자는 시스템이 요구한 프로세스에 대한 정확한 정보를 제공해야 함
우선순위
(Priority)	준비상태 큐에서 기다리는 각 프로세스마다 우선 순위를 부여하여 그 중 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법
선점 우선 순위	준비상태 큐의 프로세스들 중에서 우선 순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법
SRT(Shortest Remaining Time)	비선점 기법인 SJF 알고리즘을 선점 형태로 변경한 기법으로, 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행 시간을 비교하여 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU를 할당하는 기법
RR
(Round Robin)	․시분할 시스템(Time Sharing System)을 위해 고안된 방식으로, FCFS 알고리즘을 선점 형태로 변형한 기법
․FCFS 기법과 같이 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받지만 각 프로세스는 할당된 시간(Time Slice, Quantum) 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치됨
․할당되는 시간이 클 경우 FCFS 기법과 같아지고, 할당되는 시간이 작을 경우 문맥교환 및 오버헤드가 자주 발생됨
다단계 큐 (Multi level Queue)	프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비상태 큐를 사용하는 기법
다단계 피드백 큐(Multi level 
Feedback 
Queue)	특정 그룹의 준비상태 큐에 들어간 프로세스가 다른 준비상태 큐로 이동할 수 없는 다단계 큐 기법을 준비상태 큐 사이를 이동할 수 있도록 개선한 기법
정의	상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상
필요 
충분 
조건	․상호배제(Mutual Exclusion) : 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함
․점유와 대기 (Hold & Wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함
․비선점(Non-preemptive) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 함
․환형대기(Circular Wait) : 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함
점유 및 대기 부정	프로세스가 실행되기 전 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나 자원이 점유되지 않은 상태에서만 자원을 요구하도록 함
비선점 부정	자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 함
환형대기 부정	자원을 선형 순서로 분류하여 고유 번호를 할당하고, 각 프로세스는 현재 점유한 자원의 고유 번호보다 앞이나 뒤 어느 한쪽 방향으로만 자원을 요구하도록 하는 것
은행원 알고리즘	․Dijkstra가 제안한 것으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래한 기법
․각 프로세스에게 자원을 할당하여 교착 상태가 발생하지 않으며 모든 프로세스가 완료될 수 있는 상태를 안전 상태, 교착 상태가 발생할 수 있는 상태를 불안전 상태라고 함
요구 반입	실행 중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법
예상 반입	실행 중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법
최초 적합
(First Fit)	프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법
최적 적합
(Best Fit)	프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법
최악 적합
(Worst Fit)	프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법
페이징
(Paging) 기법	․가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법
․외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있음
세그먼테이션
(Segmentation) 기법	․가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법
․프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖고 있음
․다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치 보호키(Storage Protection Key)가 필요함
OPT 
(Optimal 
Replacement, 최적 교체)	․앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
․각 페이지의 호출 순서와 참조 상황을 미리 예측해야 하므로 실현 가능성이 희박함
FIFO(First In First Out)	․각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법
․이해하기 쉽고, 프로그래밍 및 설계가 간단하며, 벨레이디의 모순(Belady's Anomaly) 현상이 발생함
LRU(Least 
Recently Used)	․최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
․각 페이지마다 계수기나 스택을 두어 현 시점에서 가장 오랫동안 사용하지 않은 즉, 가장 오래 전에 사용된 페이지를 교체함
LFU(Least Frequently Used)	․사용 빈도가 가장 적은 페이지를 교체하는 기법
․프로그램 실행 초기에 많이 사용된 페이지가 그 후로 사용되지 않을 경우에도 프레임을 계속 차지할 수 있음
NUR
(Not Used
Recently)	․최근에 사용하지 않은 페이지를 교체하는 기법
․최근의 사용 여부를 확인하기 위해서 각 페이지마다 참조 비트(Reference Bit)와 변형 비트(Modified Dit, Dirty Bit)가 사용됨
SCR(Second Chance Replacement)	가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법 
페이지가 작을 경우	․페이지의 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어듬
․프로세스(프로그램) 수행에 필요한 내용만 주기억장치에 적재할 수 있고, Locality(국부성)에 더 일치할 수 있기 때문에 기억장치 효율이 높아짐
․페이지 정보를 갖는 페이지 맵 테이블의 크기가 커지고, 맵핑 속도가 늦어짐
․디스크 접근 횟수가 많아져서 전체적인 입․출력 시간은 늘어남
페이지가 클 경우	․페이지 정보를 갖는 페이지 맵 테이블의 크기가 작아지고, 맵핑 속도가 빨라짐
․디스크 접근 횟수가 줄어들어 전체적인 입․출력의 효율성이 증가됨
․페이지의 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어남
․프로그램 수행에 불필요한 내용까지도 주기억장치에 적재될 수 있음
시간 구역성(Temporal Locality)	․프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상
․시간 구역성이 이루어지는 기억 장소 : Loop(반복, 순환), 스택(Stack), 부프로그램(Sub Routine), Counting(1씩 증감), Totaling(집계)에 사용되는 변수(기억 장소)
공간 구역성
(Spatial Loca lity)	․프로세스 실행시 일정 위치의 페이지를 집중적으로 액세스하는 현상
․공간 구역성이 이루어지는 기억 장소 : 배열 순회(Array Tra versal), 순차적 코드의 실행, 프로그래머들이 관련된 변수(데이터를 저장할 기억장소)들을 서로 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수를 참조할 때 사용
FCFS
(First-Come
First-Service) 	․가장 간단한 스케줄링으로, 디스크 대기 큐에 가장 먼저 들어온 트랙에 대한 요청을 먼저 서비스하는 기법
․디스크 대기 큐에 들어온 순서대로 서비스하기 때문에 더 높은 우선 순위의 요청이 입력되어도 순서가 바뀌지 않아 공평성이 보장됨
SSTF
(Shortest-Seek-Time-First)	․탐색 거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스하는 기법
․현재 헤드 위치에서 가장 가까운 거리에 있는 트랙으로 헤드를 이동시킴
․FCFS보다 처리량이 많고, 평균 탐색 시간이 짧음
․처리량이 많은 일괄 처리 시스템에 유용함
SCAN	․SSTF가 갖는 탐색 시간의 편차를 해소하기 위한 기법
․현재 헤드의 위치에서 진행 방향이 결정되면 탐색 거리가 짧은 순서에 따라 그 방향의 모든 요청을 서비스하고, 끝까지 이동한 후 역방향의 요청 사항을 서비스함
C-SCAN(Circular SCAN)	․항상 바깥쪽에서 안쪽으로 움직이면서 가장 짧은 탐색 거리를 갖는 요청을 서비스하는 기법
․헤드는 트랙의 바깥쪽에서 안쪽으로 한 방향으로만 움직이며 서비스하여 끝까지 이동한 후, 안쪽에 더 이상의 요청이 없으면 헤드는 가장 바깥쪽의 끝으로 이동한 후 다시 안쪽으로 이동하면서 요청을 서비스함
N-step SCAN	SCAN 기법을 기초로 하며, 어떤 방향의 진행이 시작될 당시에 대기 중이던 요청들만 서비스하고, 진행 도중 도착한 요청들은 한데 모아서 다음의 반대 방향 진행 때 서비스하는 기법
1단계 디렉토리	․가장 간단하고, 모든 파일이 하나의 디렉토리 내에 위치하여 관리되는 구조
․모든 파일들이 유일한 이름을 가지고 있어야 함
․모든 파일이 같은 디렉토리내에 유지되므로 이해가 용이하지만, 파일의 수나 사용자의 수가 증가하면 파일 관리가 복잡해짐
2단계 디렉토리	․중앙에 마스터 파일 디렉토리가 있고, 그 아래에 사용자별로 서로 다른 파일 디렉토리가 있는 2 계층 구조
․마스터 파일 디렉토리는 사용자 파일 디렉토리를 관리하고, 사용자 파일 디렉토리는 사용자별 파일을 관리함
․서로 다른 디렉토리에서는 동일한 파일 이름을 사용할 수 있음
트리 
디렉토리	․하나의 루트 디렉토리와 여러 개의 종속(서브) 디렉토리로 구성된 구조
․DOS, Windows, UNIX 등의 운영체제에서 사용되는 디렉토리 구조
․동일한 이름의 파일이나 디렉토리를 생성할 수 있음
․디렉토리의 생성과 파괴가 비교적 용이함
비순환 그래프 디렉토리	․하위 파일이나 하위 디렉토리를 공동으로 사용할 수 있는 것으로, 사이클이 허용되지 않는 구조
․디스크 공간을 절약할 수 있음
․하나의 파일이나 디렉토리가 여러 개의 경로 이름을 가질 수 있음
․공유된 파일을 삭제할 경우 고아 포인터(Dangling Pointer)가 발생할 수 있음
일반적인 그래프 디렉토리	․트리 구조에 링크(Link)를 첨가시켜 순환을 허용하는 그래프 구조
․디렉토리와 파일 공유에 완전한 융통성이 있음
․불필요한 파일을 제거하여 사용 공간을 늘리기 위하여 참조 계수기가 필요함
섹터 단위 할당	하나의 파일이 디스크의 섹터 단위로 분산되어 할당되는 방법으로, 하나의 파일에 속하는 섹터들이 연결 리스트(Linked List)로 구성되어 있음
블록 단위 할당	․하나의 파일이 연속된 여러 개의 섹터를 묶은 블록 단위로 할당되는 방법
․블록 단위 할당에는 블록 체인 할당, 색인 블록 체인 할당, 블록 지향 파일 사상 기법이 있음
외부 보안	․시설 보안 : 천재 지변이나 외부 침입자로부터의 보안
․운용 보안 : 전산소 관리 및 경영자들의 정책과 통제에 의해 이루어지는 보안
사용자 인터페이스 
보안	운영체제가 사용자의 신원을 확인한 후 권한이 있는 사용자에게만 시스템의 프로그램과 데이터를 사용할 수 있게 하는 보안 기법
내부 보안	하드웨어나 운영체제의 내장된 보안 기능을 이용하여 시스템의 신뢰성을 유지하고, 보안 문제를 해결하는 기법
시분할 및 공유 버스	․프로세서, 주변장치, 기억장치 등의 각종 장치들간을 ‘버스’라는 단일 경로로 연결한 방식
․버스에 이상이 발생하면 전체 시스템이 가동되지 않음
․장치 연결이 단순하고, 경제적이며, 융통성이 있음
․장치 추가가 용이하지만 버스에 이상이 발생하면 전체 시스템이 가동되지 않음
크로스바 교환 행렬	․시분할 및 공유 버스 구조에서 버스의 수를 기억장치 수만큼 증가시켜 연결한 방식
․각 기억장치마다 다른 경로를 사용할 수 있음
하이퍼 큐브	․다수의 프로세서들을 연결하는 방식으로 비교적 경제적인 방식
․다수의 프로세서를 연결할 수 있으며, 확장성이 좋음
․하나의 프로세서에 연결되는 다른 프로세서의 수(연결점)가 n개 일 경우 프로세서는 총 2n개가 필요함
다중 포트 기억장치	․시분할 및 공유 버스 방식과 크로스바 교환 행렬을 혼합한 형태의 방식
․많은 수의 프로세서를 쉽게 연결할 수 있음
․다양한 연결이 가능하며, 전송 시간이 비교적 느림
주/종 처리기	․하나의 프로세서를 Master(주프로세서)로 지정하고, 나머지들은 Slave(종프로세서)로 지정하는 구조
․주프로세서가 고장나면 전체 시스템이 다운됨
․주프로세서 : 입․출력과 연산 담당, 운영체제 수행
․종프로세서 : 연산만 담당
분리 실행처리기	․주/종 처리기의 비대칭성을 보완하여 각 프로세서가 독자적인 운영체제를 가지고 있도록 구성한 구조
․각 프로세서에서 발생하는 인터럽트는 해당 프로세서에서 해결
․각 프로세서가 독자적인 운영체제를 가지고 있기 때문에 한 프로세서가 고장나더라도 전체 시스템이 다운되지 않음
대칭적 처리기	․여러 프로세서들이 완전한 기능을 갖춘 하나의 운영체제를 공유하여 수행하는 구조
․가장 복잡한 구조를 가지고 있으나 가장 강력한 시스템임
․여러 개의 프로세서가 동시에 수행될 수 있고, 시스템의 전반적인 정보를 통일적이고 일관성 있게 운영함
약결합
(Loosely Coupled) 시스템	․각 프로세서마다 독립된 메모리를 가진 시스템으로, 분산처리 시스템이라고도 함
․둘 이상의 독립된 컴퓨터 시스템을 통신망(통신 링크)을 통하여 연결한 시스템
․각 시스템마다 독자적인 운영체제를 가지고 있음
․각 시스템은 독립적으로 작동할 수도 있고, 필요한 경우에는 상호 통신할 수도 있음
․프로세서 간의 통신은 메시지 전달이나 원격 프로시저 호출을 통해서 이루어짐
․각 시스템마다 독자적인 운영이 가능하므로 CPU 간의 결합력이 약함
강결합
(Tightly Coupled) 시스템	․동일 운영체제 하에서 여러 개의 프로세서가 하나의 메모리를 공유하여 사용하는 시스템으로, 다중(병렬) 처리 시스템이라고도 함
․하나의 운영체제가 모든 프로세서와 시스템 하드웨어를 제어함
․프로세서 간의 통신은 공유 메모리를 통해서 이루어짐
․하나의 메모리를 사용하므로 CPU 간의 결합력이 강함
완전 연결
(Fully 
Connection)형	․각 사이트들이 시스템 내의 다른 모든 사이트들과 직접 연결된 구조
․사이트의 수가 n개이면 링크(연결) 수는 n(n-1)/2 개임
․기본 비용은 많이 들지만 통신 비용은 적게 들고, 신뢰성이 높음
부분 연결
(Partially 
Connection)형	․시스템 내의 일부 사이트들 간에만 직접 연결된 형태로, 직접 연결되지 않은 사이트는 연결된 다른 사이트를 통해 통신하는 구조
․기본 비용은 완전 연결형보다 적게 들고, 통신 비용은 완전 연결형보다 많이 듬
․완전 연결형보다 신뢰성이 낮음
트리(Tree)/계층(Hierarchy)형	․분산 처리 시스템의 가장 대표적인 형태로, 각 사이트들이 트리 형태로 연결된 구조
․기본 비용은 부분 연결형보다 적게 들고, 통신 비용은 트리의 깊이에 비례함
․부모(상위) 사이트의 자식(하위) 사이트들은 그 부모 사이트를 통해 통신이 이루어짐
․부모 사이트가 고장나면 그 자식 사이트들은 통신이 불가능함
스타(Star) 형/성형	․모든 사이트가 하나의 중앙 사이트에 직접 연결되어 있고, 그 외의 다른 사이트와는 연결되어 있지 않은 구조
․기본 비용은 사이트의 수에 비례하며, 통신 비용은 적게듬
․중앙 사이트를 제외한 사이트의 고장이 다른 사이트에 영향을 미치지 않지만, 중앙 사이트가 고장 날 경우 모든 통신이 단절됨
링(Ring)형/환형	․시스템 내의 각 사이트가 인접하는 다른 두 사이트와만 직접 연결된 구조
․정보는 단방향 또는 양방향으로 전달될 수 있음
․기본 비용은 사이트 수에 비례하고, 목적 사이트에 데이터를 전달하기 위해 링을 순환할 경우 통신 비용이 증가함
다중 접근 버스 연결(Multi Access Bus Connection)형	․시스템 내의 모든 사이트들이 공유 버스에 연결된 구조
․기본 비용은 사이트 수에 비례하고, 통신 비용은 일반적으로 저렴함
․사이트의 고장은 다른 사이트의 통신에 영향을 주지 않지만, 버스의 고장은 전체 시스템에 영향을 줌
커널(Kernel)	․UNIX의 가장 핵심적인 부분
․하드웨어를 보호하고, 프로그램들과 하드웨어 간의 인터페이스 역할 담당
․프로세스 관리, 기억장치 관리, 파일 관리, 입․출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러 가지 기능 수행
쉘(Shell)	․사용자의 명령어를 인식하여 프로그램을 호출하고, 명령을 수행하는 명령어 해석기
․시스템과 사용자 간의 인터페이스 담당
․DOS의 COMMAND.COM과 같은 기능 수행
․주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조기억장치에서 교체 처리 가능
유틸리티(Utility)	․일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용
․DOS에서의 외부 명령어에 해당됨
명령어	의미
fork	새로운 프로세스 생성
exec	새로운 프로세스 수행
&	백그라운드 처리를 위해 명령의 끝에 입력
mv	파일 이동, 이름 변경
rm	파일 삭제
chmod	파일의 사용 허가 지정
mount	파일 시스템을 마운팅 함
mkfs	파일 시스템 생성
chdir	현재 사용할 디렉토리 위치 변경
fsck	파일 시스템 검사․보수
rmdir	디렉토리 삭제
ls	현재 디렉토리 내의 파일 목록 확인
